{"ast":null,"code":"'use strict';\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = require('babel-runtime/helpers/inherits');\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar isObject = require('lodash.isobject');\n\nvar _require = require('../core'),\n    Suggester = _require.Suggester,\n    setDefault = _require.util.setDefault;\n/**\n * The completion suggester provides auto-complete/search-as-you-type\n * functionality. This is a navigational feature to guide users to relevant\n * results as they are typing, improving search precision. It is not meant\n * for spell correction or did-you-mean functionality like the term or\n * phrase suggesters.\n *\n * Ideally, auto-complete functionality should be as fast as a user types to\n * provide instant feedback relevant to what a user has already typed in.\n * Hence, completion suggester is optimized for speed. The suggester uses\n * data structures that enable fast lookups, but are costly to build\n * and are stored in-memory.\n *\n * Elasticsearch reference\n *   - [Completion Suggester](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-suggesters-completion.html)\n *   - [Context Suggester](https://www.elastic.co/guide/en/elasticsearch/reference/current/suggester-context.html)\n *\n * @example\n * const suggest = esb.completionSuggester('song-suggest', 'suggest').prefix('nir');\n *\n * @example\n * const suggest = new esb.CompletionSuggester('place_suggestion', 'suggest')\n *     .prefix('tim')\n *     .size(10)\n *     .contexts('place_type', ['cafe', 'restaurants']);\n *\n * @param {string} name The name of the Suggester, an arbitrary identifier\n * @param {string=} field The field to fetch the candidate suggestions from.\n *\n * @throws {Error} if `name` is empty\n *\n * @extends Suggester\n */\n\n\nvar CompletionSuggester = function (_Suggester) {\n  (0, _inherits3.default)(CompletionSuggester, _Suggester); // eslint-disable-next-line require-jsdoc\n\n  function CompletionSuggester(name, field) {\n    (0, _classCallCheck3.default)(this, CompletionSuggester);\n    return (0, _possibleConstructorReturn3.default)(this, (CompletionSuggester.__proto__ || Object.getPrototypeOf(CompletionSuggester)).call(this, 'completion', name, field));\n  }\n  /**\n   * Sets the `prefix` for the `CompletionSuggester` query.\n   *\n   * @param {string} prefix\n   * @returns {CompletionSuggester} returns `this` so that calls can be chained.\n   */\n\n\n  (0, _createClass3.default)(CompletionSuggester, [{\n    key: 'prefix',\n    value: function prefix(_prefix) {\n      this._opts.prefix = _prefix;\n      return this;\n    }\n    /**\n     * Check that the object property `this._suggestOpts.fuzzy` is an object.\n     * Set empty object if required.\n     *\n     * @private\n     */\n\n  }, {\n    key: '_checkFuzzy',\n    value: function _checkFuzzy() {\n      if (!isObject(this._suggestOpts.fuzzy)) {\n        this._suggestOpts.fuzzy = {};\n      }\n    }\n    /**\n     * Sets the `fuzzy` parameter. Can be customised with specific fuzzy parameters.\n     *\n     * @param {boolean|Object=} fuzzy Enable/disable `fuzzy` using boolean or\n     * object(with params)\n     * @returns {CompletionSuggester} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'fuzzy',\n    value: function fuzzy() {\n      var _fuzzy = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n      this._suggestOpts.fuzzy = _fuzzy;\n      return this;\n    }\n    /**\n     * Sets the `fuzziness` parameter which is interpreted as a Levenshtein Edit Distance —\n     * the number of one character changes that need to be made to one string to make it\n     * the same as another string.\n     *\n     * @example\n     * const suggest = esb.completionSuggester('song-suggest', 'suggest')\n     *     .prefix('nor')\n     *     .fuzziness(2);\n     *\n     * @param {number|string} factor Can be specified either as a number, or the maximum\n     * number of edits, or as `AUTO` which generates an edit distance based on the length\n     * of the term.\n     * @returns {CompletionSuggester} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'fuzziness',\n    value: function fuzziness(factor) {\n      this._checkFuzzy();\n\n      this._suggestOpts.fuzzy.fuzziness = factor;\n      return this;\n    }\n    /**\n     * Transpositions (`ab` → `ba`) are allowed by default but can be disabled\n     * by setting `transpositions` to false.\n     *\n     * @param {boolean} enable\n     * @returns {CompletionSuggester} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'transpositions',\n    value: function transpositions(enable) {\n      this._checkFuzzy();\n\n      this._suggestOpts.fuzzy.transpositions = enable;\n      return this;\n    }\n    /**\n     * Sets the minimum length of the input before fuzzy suggestions are returned,\n     * defaults 3\n     *\n     * @param {number} len Minimum length of the input before fuzzy suggestions\n     * are returned, defaults 3\n     * @returns {CompletionSuggester} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'minLength',\n    value: function minLength(len) {\n      this._checkFuzzy();\n\n      this._suggestOpts.fuzzy.min_length = len;\n      return this;\n    }\n    /**\n     * The number of initial characters which will not be \"fuzzified\".\n     * This helps to reduce the number of terms which must be examined. Defaults to `1`.\n     *\n     * @param {number} len Characters to skip fuzzy for. Defaults to `1`.\n     * @returns {CompletionSuggester} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'prefixLength',\n    value: function prefixLength(len) {\n      this._checkFuzzy();\n\n      this._suggestOpts.fuzzy.prefix_length = len;\n      return this;\n    }\n    /**\n     * If `true`, all measurements (like fuzzy edit distance, transpositions,\n     * and lengths) are measured in Unicode code points instead of in bytes.\n     * This is slightly slower than raw bytes, so it is set to `false` by default.\n     *\n     * @param {boolean} enable Measure in Unicode code points instead of in bytes.\n     * `false` by default.\n     * @returns {CompletionSuggester} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'unicodeAware',\n    value: function unicodeAware(enable) {\n      this._checkFuzzy();\n\n      this._suggestOpts.fuzzy.unicode_aware = enable;\n      return this;\n    }\n    /**\n     * Sets the regular expression for completion suggester which supports regex queries.\n     *\n     * @example\n     * const suggest = esb.completionSuggester('song-suggest', 'suggest')\n     *     .regex('n[ever|i]r');\n     *\n     * @param {string} expr Regular expression\n     * @returns {CompletionSuggester} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'regex',\n    value: function regex(expr) {\n      this._opts.regex = expr;\n      return this;\n    }\n    /**\n     * Set special flags. Possible flags are `ALL` (default),\n     * `ANYSTRING`, `COMPLEMENT`, `EMPTY`, `INTERSECTION`, `INTERVAL`, or `NONE`.\n     *\n     * @param {string} flags `|` separated flags. Possible flags are `ALL` (default),\n     * `ANYSTRING`, `COMPLEMENT`, `EMPTY`, `INTERSECTION`, `INTERVAL`, or `NONE`.\n     * @returns {CompletionSuggester} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'flags',\n    value: function flags(_flags) {\n      setDefault(this._suggestOpts, 'regex', {});\n      this._suggestOpts.regex.flags = _flags;\n      return this;\n    }\n    /**\n     * Limit on how many automaton states regexp queries are allowed to create.\n     * This protects against too-difficult (e.g. exponentially hard) regexps.\n     * Defaults to 10000. You can raise this limit to allow more complex regular\n     * expressions to execute.\n     *\n     * @param {number} limit\n     * @returns {CompletionSuggester} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'maxDeterminizedStates',\n    value: function maxDeterminizedStates(limit) {\n      setDefault(this._suggestOpts, 'regex', {});\n      this._suggestOpts.regex.max_determinized_states = limit;\n      return this;\n    }\n    /**\n     * The completion suggester considers all documents in the index, but it is often\n     * desirable to serve suggestions filtered and/or boosted by some criteria.\n     *\n     * To achieve suggestion filtering and/or boosting, you can add context mappings\n     * while configuring a completion field. You can define multiple context mappings\n     * for a completion field. Every context mapping has a unique name and a type.\n     *\n     * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/suggester-context.html)\n     *\n     * @example\n     * const suggest = new esb.CompletionSuggester('place_suggestion', 'suggest')\n     *     .prefix('tim')\n     *     .size(10)\n     *     .contexts('place_type', [\n     *         { context: 'cafe' },\n     *         { context: 'restaurants', boost: 2 }\n     *     ]);\n     *\n     * @example\n     * // Suggestions can be filtered and boosted with respect to how close they\n     * // are to one or more geo points. The following filters suggestions that\n     * // fall within the area represented by the encoded geohash of a geo point:\n     * const suggest = new esb.CompletionSuggester('place_suggestion', 'suggest')\n     *     .prefix('tim')\n     *     .size(10)\n     *     .contexts('location', { lat: 43.662, lon: -79.38 });\n     *\n     * @example\n     * // Suggestions that are within an area represented by a geohash can also be\n     * // boosted higher than others\n     * const suggest = new esb.CompletionSuggester('place_suggestion', 'suggest')\n     *     .prefix('tim')\n     *     .size(10)\n     *     .contexts('location', [\n     *         {\n     *             lat: 43.6624803,\n     *             lon: -79.3863353,\n     *             precision: 2\n     *         },\n     *         {\n     *             context: {\n     *                 lat: 43.6624803,\n     *                 lon: -79.3863353\n     *             },\n     *             boost: 2\n     *         }\n     *     ]);\n     *\n     * @param {string} name\n     * @param {Array|Object} ctx\n     * @returns {CompletionSuggester} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'contexts',\n    value: function contexts(name, ctx) {\n      // This whole feature is bizzare!\n      // Not very happy with the implementation.\n      setDefault(this._suggestOpts, 'contexts', {});\n      this._suggestOpts.contexts[name] = ctx;\n      return this;\n    }\n  }]);\n  return CompletionSuggester;\n}(Suggester);\n\nmodule.exports = CompletionSuggester;","map":null,"metadata":{},"sourceType":"script"}