{"ast":null,"code":"'use strict';\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = require('babel-runtime/helpers/inherits');\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar isNil = require('lodash.isnil');\n\nvar _require = require('../core'),\n    SMOOTHING_MODEL_SET = _require.consts.SMOOTHING_MODEL_SET,\n    _require$util = _require.util,\n    recursiveToJSON = _require$util.recursiveToJSON,\n    invalidParam = _require$util.invalidParam;\n\nvar AnalyzedSuggesterBase = require('./analyzed-suggester-base');\n\nvar ES_REF_URL = 'https://www.elastic.co/guide/en/elasticsearch/reference/current/search-suggesters-phrase.html';\nvar invalidSmoothingModeParam = invalidParam(ES_REF_URL, 'smoothing', SMOOTHING_MODEL_SET);\n/**\n * The phrase suggester adds additional logic on top of the `term` suggester\n * to select entire corrected phrases instead of individual tokens weighted\n * based on `ngram-language` models. In practice this suggester will be able\n * to make better decisions about which tokens to pick based on co-occurrence\n * and frequencies.\n *\n * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-suggesters-phrase.html)\n *\n * @example\n * const suggest = esb.phraseSuggester(\n *     'simple_phrase',\n *     'title.trigram',\n *     'noble prize'\n * )\n *     .size(1)\n *     .gramSize(3)\n *     .directGenerator(esb.directGenerator('title.trigram').suggestMode('always'))\n *     .highlight('<em>', '</em>');\n *\n * @param {string} name The name of the Suggester, an arbitrary identifier\n * @param {string=} field The field to fetch the candidate suggestions from.\n * @param {string=} txt A string to get suggestions for.\n *\n * @throws {Error} if `name` is empty\n *\n * @extends AnalyzedSuggesterBase\n */\n\nvar PhraseSuggester = function (_AnalyzedSuggesterBas) {\n  (0, _inherits3.default)(PhraseSuggester, _AnalyzedSuggesterBas); // eslint-disable-next-line require-jsdoc\n\n  function PhraseSuggester(name, field, txt) {\n    (0, _classCallCheck3.default)(this, PhraseSuggester);\n    return (0, _possibleConstructorReturn3.default)(this, (PhraseSuggester.__proto__ || Object.getPrototypeOf(PhraseSuggester)).call(this, 'phrase', name, field, txt));\n  }\n  /**\n   * Sets max size of the n-grams (shingles) in the `field`. If the field\n   * doesn't contain n-grams (shingles) this should be omitted or set to `1`.\n   *\n   * Note: Elasticsearch tries to detect the gram size based on\n   * the specified `field`. If the field uses a `shingle` filter the `gram_size`\n   * is set to the `max_shingle_size` if not explicitly set.\n   * @param {number} size Max size of the n-grams (shingles) in the `field`.\n   * @returns {PhraseSuggester} returns `this` so that calls can be chained.\n   */\n\n\n  (0, _createClass3.default)(PhraseSuggester, [{\n    key: 'gramSize',\n    value: function gramSize(size) {\n      this._suggestOpts.gram_size = size;\n      return this;\n    }\n    /**\n     * Sets the likelihood of a term being a misspelled even if the term exists\n     * in the dictionary. The default is `0.95` corresponding to 5% of the\n     * real words are misspelled.\n     *\n     * @param {number} factor Likelihood of a term being misspelled. Defaults to `0.95`\n     * @returns {PhraseSuggester} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'realWordErrorLikelihood',\n    value: function realWordErrorLikelihood(factor) {\n      this._suggestOpts.real_word_error_likelihood = factor;\n      return this;\n    }\n    /**\n     * Sets the confidence level defines a factor applied to the input phrases score\n     * which is used as a threshold for other suggest candidates. Only candidates\n     * that score higher than the threshold will be included in the result.\n     * For instance a confidence level of `1.0` will only return suggestions\n     * that score higher than the input phrase. If set to `0.0` the top N candidates\n     * are returned. The default is `1.0`.\n     *\n     * @param {number} level Factor applied to the input phrases score, used as\n     * a threshold for other suggest candidates.\n     * @returns {PhraseSuggester} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'confidence',\n    value: function confidence(level) {\n      this._suggestOpts.confidence = level;\n      return this;\n    }\n    /**\n     * Sets the maximum percentage of the terms that at most considered to be\n     * misspellings in order to form a correction. This method accepts a float\n     * value in the range `[0..1)` as a fraction of the actual query terms or a\n     * number `>=1` as an absolute number of query terms. The default is set\n     * to `1.0` which corresponds to that only corrections with at most\n     * 1 misspelled term are returned. Note that setting this too high can\n     * negatively impact performance. Low values like 1 or 2 are recommended\n     * otherwise the time spend in suggest calls might exceed the time spend\n     * in query execution.\n     *\n     * @param {number} limit The maximum percentage of the terms that at most considered\n     * to be misspellings in order to form a correction.\n     * @returns {PhraseSuggester} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'maxErrors',\n    value: function maxErrors(limit) {\n      this._suggestOpts.max_errors = limit;\n      return this;\n    }\n    /**\n     * Sets the separator that is used to separate terms in the bigram field.\n     * If not set the whitespace character is used as a separator.\n     *\n     * @param {string} sep The separator that is used to separate terms in the\n     * bigram field.\n     * @returns {PhraseSuggester} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'separator',\n    value: function separator(sep) {\n      this._suggestOpts.separator = sep;\n      return this;\n    }\n    /**\n     * Sets up suggestion highlighting. If not provided then no `highlighted` field\n     * is returned. If provided must contain exactly `pre_tag` and `post_tag` which\n     * are wrapped around the changed tokens. If multiple tokens in a row are changed\n     * the entire phrase of changed tokens is wrapped rather than each token.\n     *\n     * @param {string} preTag Pre-tag to wrap token\n     * @param {string} postTag Post-tag to wrap token\n     * @returns {PhraseSuggester} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'highlight',\n    value: function highlight(preTag, postTag) {\n      this._suggestOpts.highlight = {\n        pre_tag: preTag,\n        post_tag: postTag\n      };\n      return this;\n    }\n    /**\n     * Checks each suggestion against the specified `query` to prune suggestions\n     * for which no matching docs exist in the index. The collate query for\n     * a suggestion is run only on the local shard from which the suggestion\n     * has been generated from. The `query` must be specified, and it is run\n     * as a [`template` query](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-template-query.html).\n     *\n     * The current suggestion is automatically made available as the\n     * `{{suggestion}}` variable, which should be used in your query.\n     * Additionally, you can specify a `prune` to control if all phrase\n     * suggestions will be returned, when set to `true` the suggestions will\n     * have an additional option `collate_match`, which will be true if matching\n     * documents for the phrase was found, `false` otherwise. The default value\n     * for prune is `false`.\n     *\n     * @example\n     * const suggest = esb.phraseSuggester('simple_phrase', 'title.trigram')\n     *     .size(1)\n     *     .directGenerator(\n     *         esb.directGenerator('title.trigram')\n     *             .suggestMode('always')\n     *             .minWordLength(1)\n     *     )\n     *     .collate({\n     *         query: {\n     *             inline: {\n     *                 match: {\n     *                     '{{field_name}}': '{{suggestion}}'\n     *                 }\n     *             }\n     *         },\n     *         params: { field_name: 'title' },\n     *         prune: true\n     *     });\n     *\n     * @param {Object} opts The options for `collate`. Can include the following:\n     *   - `query`: The `query` to prune suggestions for which\n     *      no matching docs exist in the index. It is run as a `template` query.\n     *   - `params`: The parameters to be passed to the template. The suggestion\n     *      value will be added to the variables you specify.\n     *   - `prune`: When set to `true`, the suggestions will\n     *      have an additional option `collate_match`, which will be true if matching\n     *      documents for the phrase was found, `false` otherwise. The default value\n     *      for prune is `false`.\n     * @returns {PhraseSuggester} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'collate',\n    value: function collate(opts) {\n      // Add an instance check here?\n      // I wanted to use `SearchTemplate` here since the syntaqx is deceptively\n      // similar. But not quite the same.\n      // Adding a builder object called collate doesn't make sense either.\n      this._suggestOpts.collate = opts;\n      return this;\n    }\n    /**\n     * Sets the smoothing model to balance weight between infrequent grams\n     * (grams (shingles) are not existing in the index) and frequent grams\n     * (appear at least once in the index).\n     *\n     * Three possible values can be specified:\n     *   - `stupid_backoff`: a simple backoff model that backs off to lower order\n     *     n-gram models if the higher order count is 0 and discounts the lower order\n     *     n-gram model by a constant factor. The default `discount` is `0.4`.\n     *     Stupid Backoff is the default model\n     *   - `laplace`: a smoothing model that uses an additive smoothing where a\n     *     constant (typically `1.0` or smaller) is added to all counts to balance weights,\n     *     The default `alpha` is `0.5`.\n     *   - `linear_interpolation`: a smoothing model that takes the weighted mean of the\n     *     unigrams, bigrams and trigrams based on user supplied weights (lambdas).\n     *     Linear Interpolation doesn’t have any default values.\n     *     All parameters (`trigram_lambda`, `bigram_lambda`, `unigram_lambda`)\n     *     must be supplied.\n     *\n     * @param {string} model One of `stupid_backoff`, `laplace`, `linear_interpolation`\n     * @returns {PhraseSuggester} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'smoothing',\n    value: function smoothing(model) {\n      if (isNil(model)) invalidSmoothingModeParam(model);\n      var modelLower = model.toLowerCase();\n\n      if (!SMOOTHING_MODEL_SET.has(modelLower)) {\n        invalidSmoothingModeParam(model);\n      }\n\n      this._suggestOpts.smoothing = modelLower;\n      return this;\n    }\n    /**\n     * Sets the given list of candicate generators which produce a list of possible terms\n     * per term in the given text. Each of the generators in the list are\n     * called per term in the original text.\n     *\n     * The output of the generators is subsequently scored in combination with the\n     * candidates from the other terms to for suggestion candidates.\n     *\n     * @example\n     * const suggest = esb.phraseSuggester('simple_phrase', 'title.trigram')\n     *     .size(1)\n     *     .directGenerator([\n     *         esb.directGenerator('title.trigram').suggestMode('always'),\n     *         esb.directGenerator('title.reverse')\n     *             .suggestMode('always')\n     *             .preFilter('reverse')\n     *             .postFilter('reverse')\n     *     ]);\n     *\n     * @param {Array<DirectGenerator>|DirectGenerator} dirGen Array of `DirectGenerator`\n     * instances or a single instance of `DirectGenerator`\n     * @returns {PhraseSuggester} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'directGenerator',\n    value: function directGenerator(dirGen) {\n      // TODO: Do instance checks on `dirGen`\n      this._suggestOpts.direct_generator = Array.isArray(dirGen) ? dirGen : [dirGen];\n      return this;\n    }\n    /**\n     * Override default `toJSON` to return DSL representation for the `phrase suggester`\n     *\n     * @override\n     * @returns {Object} returns an Object which maps to the elasticsearch DSL\n     */\n\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return recursiveToJSON(this._body);\n    }\n  }]);\n  return PhraseSuggester;\n}(AnalyzedSuggesterBase);\n\nmodule.exports = PhraseSuggester;","map":null,"metadata":{},"sourceType":"script"}