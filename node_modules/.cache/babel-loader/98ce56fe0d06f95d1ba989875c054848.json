{"ast":null,"code":"'use strict';\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = require('babel-runtime/helpers/inherits');\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar isEmpty = require('lodash.isempty');\n\nvar _require = require('../../core'),\n    Query = _require.Query,\n    _require$util = _require.util,\n    checkType = _require$util.checkType,\n    setDefault = _require$util.setDefault;\n\nvar BucketAggregationBase = require('./bucket-aggregation-base');\n\nvar ES_REF_URL = 'https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-filters-aggregation.html';\n/**\n * Defines a single bucket of all the documents in the current document set\n * context that match a specified filter. Often this will be used to narrow down\n * the current aggregation context to a specific set of documents.\n *\n * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-filters-aggregation.html)\n *\n * @example\n * const agg = esb.filtersAggregation('messages')\n *     .filter('errors', esb.matchQuery('body', 'error'))\n *     .filter('warnings', esb.matchQuery('body', 'warning'));\n *\n *\n * @example\n * const agg = esb.filtersAggregation('messages')\n *     .anonymousFilters([\n *         esb.matchQuery('body', 'error'),\n *         esb.matchQuery('body', 'warning')\n *     ])\n *\n * @param {string} name The name which will be used to refer to this aggregation.\n *\n * @extends BucketAggregationBase\n */\n\nvar FiltersAggregation = function (_BucketAggregationBas) {\n  (0, _inherits3.default)(FiltersAggregation, _BucketAggregationBas); // eslint-disable-next-line require-jsdoc\n\n  function FiltersAggregation(name) {\n    (0, _classCallCheck3.default)(this, FiltersAggregation);\n    return (0, _possibleConstructorReturn3.default)(this, (FiltersAggregation.__proto__ || Object.getPrototypeOf(FiltersAggregation)).call(this, name, 'filters'));\n  }\n  /**\n   * @override\n   * @throws {Error} This method cannot be called on FiltersAggregation\n   */\n\n\n  (0, _createClass3.default)(FiltersAggregation, [{\n    key: 'field',\n    value: function field() {\n      console.log('Please refer ' + ES_REF_URL);\n      throw new Error('field is not supported in FiltersAggregation');\n    }\n    /**\n     * @override\n     * @throws {Error} This method cannot be called on FiltersAggregation\n     */\n\n  }, {\n    key: 'script',\n    value: function script() {\n      console.log('Please refer ' + ES_REF_URL);\n      throw new Error('script is not supported in FiltersAggregation');\n    }\n    /**\n     * Print warning message to console namespaced by class name.\n     *\n     * @param {string} msg\n     * @private\n     */\n\n  }, {\n    key: '_warn',\n    value: function _warn(msg) {\n      console.warn('[FiltersAggregation] ' + msg);\n    }\n    /**\n     * Check and puts an object for the `filters` key in\n     * internal aggregation representation object.\n     * If the key has a value but is not an object,\n     * a warning is printed.\n     * @private\n     */\n\n  }, {\n    key: '_checkNamedFilters',\n    value: function _checkNamedFilters() {\n      if (!setDefault(this._aggsDef, 'filters', {}) && Array.isArray(this._aggsDef.filters)) {\n        this._warn('Do not mix named and anonymous filters!');\n\n        this._warn('Overwriting anonymous filters.');\n\n        this._aggsDef.filters = {};\n      }\n    }\n    /**\n     * Check and puts an array for the `filters` key in\n     * internal aggregation representation object.\n     * If the key has a value but is not an array,\n     * a warning is printed.\n     * @private\n     */\n\n  }, {\n    key: '_checkAnonymousFilters',\n    value: function _checkAnonymousFilters() {\n      if (!setDefault(this._aggsDef, 'filters', []) && !Array.isArray(this._aggsDef.filters)) {\n        this._warn('Do not mix named and anonymous filters!');\n\n        this._warn('Overwriting named filters.');\n\n        this._aggsDef.filters = [];\n      }\n    }\n    /**\n     * Sets a named filter query.\n     * Does not mix with anonymous filters.\n     * If anonymous filters are present, they will be overwritten.\n     *\n     * @param {string} bucketName Name for bucket which will collect\n     * all documents that match its associated filter.\n     * @param {Query} filterQuery Query to filter on. Example - term query.\n     * @returns {FiltersAggregation} returns `this` so that calls can be chained\n     * @throws {TypeError} If `filterQuery` is not an instance of `Query`\n     */\n\n  }, {\n    key: 'filter',\n    value: function filter(bucketName, filterQuery) {\n      checkType(filterQuery, Query);\n\n      this._checkNamedFilters();\n\n      this._aggsDef.filters[bucketName] = filterQuery;\n      return this;\n    }\n    /**\n     * Assigns filters to already added filters.\n     * Does not mix with anonymous filters.\n     * If anonymous filters are present, they will be overwritten.\n     *\n     * @param {Object} filterQueries Object with multiple key value pairs\n     * where bucket name is the key and filter query is the value.\n     * @returns {FiltersAggregation} returns `this` so that calls can be chained\n     * @throws {TypeError} If `filterQueries` is not an instance of object\n     */\n\n  }, {\n    key: 'filters',\n    value: function filters(filterQueries) {\n      checkType(filterQueries, Object);\n\n      this._checkNamedFilters();\n\n      Object.assign(this._aggsDef.filters, filterQueries);\n      return this;\n    }\n    /**\n     * Appends an anonymous filter query.\n     * Does not mix with named filters.\n     * If named filters are present, they will be overwritten.\n     *\n     * @param {*} filterQuery Query to filter on. Example - term query.\n     * @returns {FiltersAggregation} returns `this` so that calls can be chained\n     * @throws {TypeError} If `filterQuery` is not an instance of `Query`\n     */\n\n  }, {\n    key: 'anonymousFilter',\n    value: function anonymousFilter(filterQuery) {\n      checkType(filterQuery, Query);\n\n      this._checkAnonymousFilters();\n\n      this._aggsDef.filters.push(filterQuery);\n\n      return this;\n    }\n    /**\n     * Appends an array of anonymous filters.\n     * Does not mix with named filters.\n     * If named filters are present, they will be overwritten.\n     *\n     * @param {*} filterQueries Array of queries to filter on and generate buckets.\n     * Example - term query.\n     * @returns {FiltersAggregation} returns `this` so that calls can be chained\n     * @throws {TypeError} If `filterQueries` is not an instance of Array\n     */\n\n  }, {\n    key: 'anonymousFilters',\n    value: function anonymousFilters(filterQueries) {\n      checkType(filterQueries, Array);\n\n      this._checkAnonymousFilters();\n\n      this._aggsDef.filters = this._aggsDef.filters.concat(filterQueries);\n      return this;\n    }\n    /**\n     * Adds a bucket to the response which will contain all documents\n     * that do not match any of the given filters.\n     * Returns the other bucket bucket either in a bucket\n     * (named `_other_` by default) if named filters are being used,\n     * or as the last bucket if anonymous filters are being used\n     *\n     * @param {boolean} enable `True` to return `other` bucket with documents\n     * that do not match any filters and `False` to disable computation\n     * @param {string=} otherBucketKey Optional key for the other bucket.\n     * Default is `_other_`.\n     * @returns {FiltersAggregation} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'otherBucket',\n    value: function otherBucket(enable, otherBucketKey) {\n      this._aggsDef.other_bucket = enable;\n      !isEmpty(otherBucketKey) && this.otherBucketKey(otherBucketKey);\n      return this;\n    }\n    /**\n     * Sets the key for the other bucket to a value other than the default `_other_`.\n     * Setting this parameter will implicitly set the other_bucket parameter to true.\n     * If anonymous filters are being used, setting this parameter will not make sense.\n     *\n     * @example\n     * const agg = esb.filtersAggregation('messages')\n     *     .filter('errors', esb.matchQuery('body', 'error'))\n     *     .filter('warnings', esb.matchQuery('body', 'warning'))\n     *     .otherBucketKey('other_messages');\n     *\n     * @param {string} otherBucketKey\n     * @returns {FiltersAggregation} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'otherBucketKey',\n    value: function otherBucketKey(_otherBucketKey) {\n      this._aggsDef.other_bucket_key = _otherBucketKey;\n      return this;\n    }\n  }]);\n  return FiltersAggregation;\n}(BucketAggregationBase);\n\nmodule.exports = FiltersAggregation;","map":null,"metadata":{},"sourceType":"script"}