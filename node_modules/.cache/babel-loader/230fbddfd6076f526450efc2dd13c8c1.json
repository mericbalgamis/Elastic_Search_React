{"ast":null,"code":"'use strict';\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = require('babel-runtime/helpers/inherits');\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar _require = require('../../core'),\n    checkType = _require.util.checkType;\n\nvar MetricsAggregationBase = require('./metrics-aggregation-base');\n/**\n * A multi-value metrics aggregation that calculates one or more percentiles\n * over numeric values extracted from the aggregated documents. These values can\n * be extracted either from specific numeric fields in the documents, or be\n * generated by a provided script.\n *\n * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-percentile-aggregation.html)\n *\n * Aggregation that calculates one or more percentiles over numeric values\n * extracted from the aggregated documents.\n *\n * @example\n * const agg = esb.percentilesAggregation('load_time_outlier', 'load_time');\n *\n * @example\n * // Convert load time from mills to seconds on-the-fly using script\n * const agg = esb.percentilesAggregation('load_time_outlier').script(\n *     esb.script('inline', \"doc['load_time'].value / params.timeUnit\")\n *         .lang('painless')\n *         .params({ timeUnit: 1000 })\n * );\n *\n * @param {string} name The name which will be used to refer to this aggregation.\n * @param {string=} field The field to aggregate on\n *\n * @extends MetricsAggregationBase\n */\n\n\nvar PercentilesAggregation = function (_MetricsAggregationBa) {\n  (0, _inherits3.default)(PercentilesAggregation, _MetricsAggregationBa); // eslint-disable-next-line require-jsdoc\n\n  function PercentilesAggregation(name, field) {\n    (0, _classCallCheck3.default)(this, PercentilesAggregation);\n    return (0, _possibleConstructorReturn3.default)(this, (PercentilesAggregation.__proto__ || Object.getPrototypeOf(PercentilesAggregation)).call(this, name, 'percentiles', field));\n  }\n  /**\n   * Enable the response to be returned as a keyed object where the key is the\n   * bucket interval.\n   *\n   * @example\n   * // Return the ranges as an array rather than a hash\n   * const agg = esb.percentilesAggregation('balance_outlier', 'balance').keyed(\n   *     false\n   * );\n   *\n   * @param {boolean} keyed To enable keyed response or not. True by default\n   * @returns {PercentilesAggregation} returns `this` so that calls can be chained\n   */\n\n\n  (0, _createClass3.default)(PercentilesAggregation, [{\n    key: 'keyed',\n    value: function keyed(_keyed) {\n      this._aggsDef.keyed = _keyed;\n      return this;\n    }\n    /**\n     * Specifies the percents of interest.\n     * Requested percentiles must be a value between 0-100 inclusive\n     *\n     * @example\n     * // Specify particular percentiles to calculate\n     * const agg = esb.percentilesAggregation(\n     *     'load_time_outlier',\n     *     'load_time'\n     * ).percents([95, 99, 99.9]);\n     *\n     * @param {Array<number>} percents Parameter to specify particular percentiles to calculate\n     * @returns {PercentilesAggregation} returns `this` so that calls can be chained\n     * @throws {TypeError} If `percents` is not an instance of Array\n     */\n\n  }, {\n    key: 'percents',\n    value: function percents(_percents) {\n      checkType(_percents, Array);\n      this._aggsDef.percents = _percents;\n      return this;\n    }\n    /**\n     * Compression controls memory usage and approximation error. The compression\n     * value limits the maximum number of nodes to 100 * compression. By\n     * increasing the compression value, you can increase the accuracy of your\n     * percentiles at the cost of more memory. Larger compression values also make\n     * the algorithm slower since the underlying tree data structure grows in\n     * size, resulting in more expensive operations. The default compression\n     * value is 100.\n     *\n     * @example\n     * const agg = esb.percentilesAggregation(\n     *     'load_time_outlier',\n     *     'load_time'\n     * ).tdigest(200);\n     *\n     * @param {number} compression Parameter to balance memory utilization with estimation accuracy.\n     * @returns {PercentilesAggregation} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'tdigest',\n    value: function tdigest(compression) {\n      this._aggsDef.tdigest = {\n        compression: compression\n      };\n      return this;\n    }\n    /**\n     * Compression controls memory usage and approximation error. The compression\n     * value limits the maximum number of nodes to 100 * compression. By\n     * increasing the compression value, you can increase the accuracy of your\n     * percentiles at the cost of more memory. Larger compression values also make\n     * the algorithm slower since the underlying tree data structure grows in\n     * size, resulting in more expensive operations. The default compression\n     * value is 100.\n     *\n     * Alias for `tdigest`\n     *\n     * @example\n     * const agg = esb.percentilesAggregation(\n     *     'load_time_outlier',\n     *     'load_time'\n     * ).compression(200);\n     *\n     * @param {number} compression Parameter to balance memory utilization with estimation accuracy.\n     * @returns {PercentilesAggregation} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'compression',\n    value: function compression(_compression) {\n      this._aggsDef.tdigest = {\n        compression: _compression\n      };\n      return this;\n    }\n    /**\n     * HDR Histogram (High Dynamic Range Histogram) is an alternative implementation\n     * that can be useful when calculating percentiles for latency measurements\n     * as it can be faster than the t-digest implementation\n     * with the trade-off of a larger memory footprint.\n     *\n     * The HDR Histogram can be used by specifying the method parameter in the request.\n     *\n     * @example\n     * const agg = esb.percentilesAggregation('load_time_outlier', 'load_time')\n     *     .percents([95, 99, 99.9])\n     *     .hdr(3);\n     *\n     * @param {number} numberOfSigDigits The resolution of values\n     * for the histogram in number of significant digits\n     * @returns {PercentilesAggregation} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'hdr',\n    value: function hdr(numberOfSigDigits) {\n      this._aggsDef.hdr = {\n        number_of_significant_value_digits: numberOfSigDigits\n      };\n      return this;\n    }\n  }]);\n  return PercentilesAggregation;\n}(MetricsAggregationBase);\n\nmodule.exports = PercentilesAggregation;","map":null,"metadata":{},"sourceType":"script"}