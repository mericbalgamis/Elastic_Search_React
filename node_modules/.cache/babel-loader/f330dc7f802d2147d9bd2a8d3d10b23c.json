{"ast":null,"code":"'use strict';\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = require('babel-runtime/helpers/inherits');\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar isNil = require('lodash.isnil');\n\nvar _require = require('../../core'),\n    checkType = _require.util.checkType;\n\nvar MetricsAggregationBase = require('./metrics-aggregation-base');\n\nvar ES_REF_URL = 'https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-percentile-rank-aggregation.html';\n/**\n * A multi-value metrics aggregation that calculates one or more percentile ranks\n * over numeric values extracted from the aggregated documents. These values can\n * be extracted either from specific numeric fields in the documents, or be\n * generated by a provided script.\n *\n * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-percentile-rank-aggregation.html)\n *\n * Aggregation that calculates one or more percentiles ranks over numeric values\n * extracted from the aggregated documents.\n *\n * @example\n * const agg = esb.percentileRanksAggregation(\n *     'load_time_outlier',\n *     'load_time',\n *     [15, 30]\n * );\n *\n * @example\n * // Convert load time from mills to seconds on-the-fly using script\n * const agg = esb.percentileRanksAggregation('load_time_outlier')\n *     .values([3, 5])\n *     .script(\n *         esb.script('inline', \"doc['load_time'].value / params.timeUnit\")\n *             .lang('painless')\n *             .params({ timeUnit: 1000 })\n *     );\n *\n * @param {string} name The name which will be used to refer to this aggregation.\n * @param {string=} field The field to aggregate on. It must be a numeric field\n * @param {Array=} values Values to compute percentiles from.\n *\n * @throws {TypeError} If `values` is not an instance of Array\n *\n * @extends MetricsAggregationBase\n */\n\nvar PercentileRanksAggregation = function (_MetricsAggregationBa) {\n  (0, _inherits3.default)(PercentileRanksAggregation, _MetricsAggregationBa); // eslint-disable-next-line require-jsdoc\n\n  function PercentileRanksAggregation(name, field, values) {\n    (0, _classCallCheck3.default)(this, PercentileRanksAggregation);\n\n    var _this = (0, _possibleConstructorReturn3.default)(this, (PercentileRanksAggregation.__proto__ || Object.getPrototypeOf(PercentileRanksAggregation)).call(this, name, 'percentile_ranks', field));\n\n    if (!isNil(values)) _this.values(values);\n    return _this;\n  }\n  /**\n   * @override\n   * @throws {Error} This method cannot be called on PercentileRanksAggregation\n   */\n\n\n  (0, _createClass3.default)(PercentileRanksAggregation, [{\n    key: 'format',\n    value: function format() {\n      // Not 100% sure about this.\n      console.log('Please refer ' + ES_REF_URL);\n      throw new Error('format is not supported in PercentileRanksAggregation');\n    }\n    /**\n     * Enable the response to be returned as a keyed object where the key is the\n     * bucket interval.\n     *\n     * @example\n     * // Return the ranges as an array rather than a hash\n     * const agg = esb.percentileRanksAggregation('balance_outlier', 'balance')\n     *     .values([25000, 50000])\n     *     .keyed(false);\n     *\n     * @param {boolean} keyed To enable keyed response or not.\n     * @returns {PercentilesRanksAggregation} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'keyed',\n    value: function keyed(_keyed) {\n      this._aggsDef.keyed = _keyed;\n      return this;\n    }\n    /**\n     * Specifies the values to compute percentiles from.\n     *\n     * @param {Array<number>} values Values to compute percentiles from.\n     * @returns {PercentileRanksAggregation} returns `this` so that calls can be chained\n     * @throws {TypeError} If `values` is not an instance of Array\n     */\n\n  }, {\n    key: 'values',\n    value: function values(_values) {\n      checkType(_values, Array);\n      this._aggsDef.values = _values;\n      return this;\n    }\n    /**\n     * Compression controls memory usage and approximation error. The compression\n     * value limits the maximum number of nodes to 100 * compression. By\n     * increasing the compression value, you can increase the accuracy of your\n     * percentiles at the cost of more memory. Larger compression values also make\n     * the algorithm slower since the underlying tree data structure grows in\n     * size, resulting in more expensive operations. The default compression\n     * value is 100.\n     *\n     * @param {number} compression Parameter to balance memory utilization with estimation accuracy.\n     * @returns {PercentileRanksAggregation} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'tdigest',\n    value: function tdigest(compression) {\n      this._aggsDef.tdigest = {\n        compression: compression\n      };\n      return this;\n    }\n    /**\n     * Compression controls memory usage and approximation error. The compression\n     * value limits the maximum number of nodes to 100 * compression. By\n     * increasing the compression value, you can increase the accuracy of your\n     * percentiles at the cost of more memory. Larger compression values also make\n     * the algorithm slower since the underlying tree data structure grows in\n     * size, resulting in more expensive operations. The default compression\n     * value is 100.\n     *\n     * Alias for `tdigest`\n     *\n     * @param {number} compression Parameter to balance memory utilization with estimation accuracy.\n     * @returns {PercentileRanksAggregation} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'compression',\n    value: function compression(_compression) {\n      return this.tdigest(_compression);\n    }\n    /**\n     * HDR Histogram (High Dynamic Range Histogram) is an alternative implementation\n     * that can be useful when calculating percentiles for latency measurements\n     * as it can be faster than the t-digest implementation\n     * with the trade-off of a larger memory footprint.\n     *\n     * The HDR Histogram can be used by specifying the method parameter in the request.\n     *\n     * @example\n     * const agg = esb.percentileRanksAggregation(\n     *     'load_time_outlier',\n     *     'load_time',\n     *     [15, 30]\n     * ).hdr(3);\n     *\n     * @param {number} numberOfSigDigits The resolution of values\n     * for the histogram in number of significant digits\n     * @returns {PercentileRanksAggregation} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'hdr',\n    value: function hdr(numberOfSigDigits) {\n      this._aggsDef.hdr = {\n        number_of_significant_value_digits: numberOfSigDigits\n      };\n      return this;\n    }\n  }]);\n  return PercentileRanksAggregation;\n}(MetricsAggregationBase);\n\nmodule.exports = PercentileRanksAggregation;","map":null,"metadata":{},"sourceType":"script"}