{"ast":null,"code":"'use strict';\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _get2 = require('babel-runtime/helpers/get');\n\nvar _get3 = _interopRequireDefault(_get2);\n\nvar _inherits2 = require('babel-runtime/helpers/inherits');\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar isEmpty = require('lodash.isempty');\n\nvar _require = require('../../core'),\n    checkType = _require.util.checkType;\n\nvar BucketAggregationBase = require('./bucket-aggregation-base');\n\nvar hasOwnProp = Object.prototype.hasOwnProperty;\n/**\n * The `RangeAggregationBase` provides support for common options used across\n * various range `Aggregation` implementations like Range Aggregation and\n * Date Range aggregation.\n *\n * **NOTE:** Instantiating this directly should not be required.\n * However, if you wish to add a custom implementation for whatever reason,\n * this class could be extended.\n *\n * @param {string} name The name which will be used to refer to this aggregation.\n * @param {string} aggType Type of aggregation\n * @param {string=} field The field to aggregate on\n *\n * @extends BucketAggregationBase\n */\n\nvar RangeAggregationBase = function (_BucketAggregationBas) {\n  (0, _inherits3.default)(RangeAggregationBase, _BucketAggregationBas); // eslint-disable-next-line require-jsdoc\n\n  function RangeAggregationBase(name, aggType, field) {\n    (0, _classCallCheck3.default)(this, RangeAggregationBase); // Variable name is misleading. Only one of these needs to be present.\n\n    var _this = (0, _possibleConstructorReturn3.default)(this, (RangeAggregationBase.__proto__ || Object.getPrototypeOf(RangeAggregationBase)).call(this, name, aggType, field));\n\n    _this._rangeRequiredKeys = ['from', 'to'];\n    _this._aggsDef.ranges = [];\n    return _this;\n  }\n  /**\n   * Sets the format expression for `key_as_string` in response buckets.\n   * If no format is specified, then it will use the format specified in the field mapping.\n   *\n   * @param {string} fmt Supports expressive [date format pattern](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-daterange-aggregation.html#date-format-pattern) for Date Histograms\n   * @returns {RangeAggregationBase} returns `this` so that calls can be chained\n   */\n\n\n  (0, _createClass3.default)(RangeAggregationBase, [{\n    key: 'format',\n    value: function format(fmt) {\n      this._aggsDef.format = fmt;\n      return this;\n    }\n    /**\n     * Adds a range to the list of existing range expressions.\n     *\n     * @param {Object} range Range to aggregate over. Valid keys are `from`, `to` and `key`\n     * @returns {RangeAggregationBase} returns `this` so that calls can be chained\n     *\n     * @throws {TypeError} If `range` is not an instance of object\n     * @throws {Error} If none of the required keys,\n     * `from`, `to` or `mask`(for IP range) is passed\n     */\n\n  }, {\n    key: 'range',\n    value: function range(_range) {\n      checkType(_range, Object);\n\n      if (!this._rangeRequiredKeys.some(hasOwnProp, _range)) {\n        throw new Error('Invalid Range! Range must have at least one of ' + this._rangeRequiredKeys);\n      }\n\n      this._aggsDef.ranges.push(_range);\n\n      return this;\n    }\n    /**\n     * Adds the list of ranges to the list of existing range expressions.\n     *\n     * @param {Array<Object>} ranges Ranges to aggregate over.\n     * Each item must be an object with keys `from`, `to` and `key`.\n     * @returns {RangeAggregationBase} returns `this` so that calls can be chained\n     *\n     * @throws {TypeError} If `ranges` is not an instance of an array or\n     * and item in the array is not an instance of object\n     * @throws {Error} If none of the required keys,\n     * `from`, `to` or `mask`(for IP range) is passed\n     */\n\n  }, {\n    key: 'ranges',\n    value: function ranges(_ranges) {\n      var _this2 = this;\n\n      checkType(_ranges, Array);\n\n      _ranges.forEach(function (range) {\n        return _this2.range(range);\n      });\n\n      return this;\n    }\n    /**\n     * Sets the missing parameter ehich defines how documents\n     * that are missing a value should be treated.\n     *\n     * @param {string} value\n     * @returns {RangeAggregationBase} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'missing',\n    value: function missing(value) {\n      this._aggsDef.missing = value;\n      return this;\n    }\n    /**\n     * Enable the response to be returned as a keyed object where the key is the\n     * bucket interval.\n     *\n     * @example\n     * const agg = esb.dateRangeAggregation('range', 'date')\n     *     .format('MM-yyy')\n     *     .ranges([{ to: 'now-10M/M' }, { from: 'now-10M/M' }])\n     *     .keyed(true);\n     *\n     * @example\n     * const agg = esb.geoDistanceAggregation('rings_around_amsterdam', 'location')\n     *     .origin(esb.geoPoint().string('52.3760, 4.894'))\n     *     .ranges([\n     *         { to: 100000, key: 'first_ring' },\n     *         { from: 100000, to: 300000, key: 'second_ring' },\n     *         { from: 300000, key: 'third_ring' }\n     *     ])\n     *     .keyed(true);\n     *\n     * @param {boolean} keyed To enable keyed response or not.\n     * @returns {RangeAggregationBase} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'keyed',\n    value: function keyed(_keyed) {\n      this._aggsDef.keyed = _keyed;\n      return this;\n    }\n    /**\n     * Override default `toJSON` to return DSL representation for the `aggregation` query.\n     *\n     * @override\n     * @returns {Object} returns an Object which maps to the elasticsearch query DSL\n     */\n\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      if (isEmpty(this._aggsDef.ranges)) {\n        throw new Error('`ranges` cannot be empty.');\n      }\n\n      return (0, _get3.default)(RangeAggregationBase.prototype.__proto__ || Object.getPrototypeOf(RangeAggregationBase.prototype), 'toJSON', this).call(this);\n    }\n  }]);\n  return RangeAggregationBase;\n}(BucketAggregationBase);\n\nmodule.exports = RangeAggregationBase;","map":null,"metadata":{},"sourceType":"script"}