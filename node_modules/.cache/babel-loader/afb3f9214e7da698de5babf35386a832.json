{"ast":null,"code":"'use strict';\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = require('babel-runtime/helpers/inherits');\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar isNil = require('lodash.isnil');\n\nvar _require = require('../../core'),\n    invalidParam = _require.util.invalidParam;\n\nvar MonoFieldQueryBase = require('./mono-field-query-base');\n\nvar _require2 = require('../helper'),\n    validateRewiteMethod = _require2.validateRewiteMethod;\n\nvar ES_REF_URL = 'https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query.html';\nvar invalidOperatorParam = invalidParam(ES_REF_URL, 'operator', \"'and' or 'or'\");\nvar invalidZeroTermsQueryParam = invalidParam(ES_REF_URL, 'zero_terms_query', \"'all' or 'none'\");\n/**\n * `match` query accepts text/numerics/dates, analyzes them, and constructs a query.\n *\n * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query.html)\n *\n * @param {string=} field The document field to query against\n * @param {string=} queryString The query string\n *\n * @example\n * const matchQry = esb.matchQuery('message', 'to be or not to be');\n *\n * @extends MonoFieldQueryBase\n */\n\nvar MatchQuery = function (_MonoFieldQueryBase) {\n  (0, _inherits3.default)(MatchQuery, _MonoFieldQueryBase); // NOTE: Did not add methods for `slop`, `phrase_slop` and `type`.\n  // These are deprecated.\n  // eslint-disable-next-line require-jsdoc\n\n  function MatchQuery(field, queryString) {\n    (0, _classCallCheck3.default)(this, MatchQuery);\n    return (0, _possibleConstructorReturn3.default)(this, (MatchQuery.__proto__ || Object.getPrototypeOf(MatchQuery)).call(this, 'match', field, queryString));\n  }\n  /**\n   * The operator to be used in the boolean query which is constructed\n   * by analyzing the text provided. The `operator` flag can be set to `or` or\n   * `and` to control the boolean clauses (defaults to `or`).\n   *\n   * @param {string} operator Can be `and`/`or`. Default is `or`.\n   * @returns {MatchQuery} returns `this` so that calls can be chained.\n   */\n\n\n  (0, _createClass3.default)(MatchQuery, [{\n    key: 'operator',\n    value: function operator(_operator) {\n      if (isNil(_operator)) invalidOperatorParam(_operator);\n\n      var operatorLower = _operator.toLowerCase();\n\n      if (operatorLower !== 'and' && operatorLower !== 'or') {\n        invalidOperatorParam(_operator);\n      }\n\n      this._queryOpts.operator = operatorLower;\n      return this;\n    }\n    /**\n     * Sets the `lenient` parameter which allows to ignore exceptions caused\n     * by data-type mismatches such as trying to query a numeric field with a\n     * text query string when set to `true`.\n     *\n     * @param {boolean} enable Defaules to `false`\n     * @returns {MatchQuery} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'lenient',\n    value: function lenient(enable) {\n      this._queryOpts.lenient = enable;\n      return this;\n    }\n    /**\n     * Sets the `fuzziness` parameter which is interpreted as a Levenshtein Edit Distance —\n     * the number of one character changes that need to be made to one string to make it\n     * the same as another string.\n     *\n     * @example\n     * const qry = esb.matchQuery('message', 'this is a test').operator('and');\n     *\n     * @param {number|string} factor Can be specified either as a number, or the maximum\n     * number of edits, or as `AUTO` which generates an edit distance based on the length\n     * of the term.\n     * @returns {MatchQuery} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'fuzziness',\n    value: function fuzziness(factor) {\n      this._queryOpts.fuzziness = factor;\n      return this;\n    }\n    /**\n     * Sets the prefix length for a fuzzy prefix `MatchQuery`\n     *\n     * @param {number} len\n     * @returns {MatchQuery} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'prefixLength',\n    value: function prefixLength(len) {\n      this._queryOpts.prefix_length = len;\n      return this;\n    }\n    /**\n     * Sets the max expansions for a fuzzy prefix `MatchQuery`\n     *\n     * @param {number} limit\n     * @returns {MatchQuery} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'maxExpansions',\n    value: function maxExpansions(limit) {\n      this._queryOpts.max_expansions = limit;\n      return this;\n    }\n    /**\n     * Sets the rewrite method. Valid values are:\n     * - `constant_score` - tries to pick the best constant-score rewrite\n     *  method based on term and document counts from the query.\n     *  Synonyms - `constant_score_auto`, `constant_score_filter`\n     *\n     * - `scoring_boolean` - translates each term into boolean should and\n     *  keeps the scores as computed by the query\n     *\n     * - `constant_score_boolean` - same as `scoring_boolean`, expect no scores\n     *  are computed.\n     *\n     * - `constant_score_filter` - first creates a private Filter, by visiting\n     *  each term in sequence and marking all docs for that term\n     *\n     * - `top_terms_boost_N` - first translates each term into boolean should\n     *  and scores are only computed as the boost using the top N\n     *  scoring terms. Replace N with an integer value.\n     *\n     * - `top_terms_N` - first translates each term into boolean should\n     *  and keeps the scores as computed by the query. Only the top N\n     *  scoring terms are used. Replace N with an integer value.\n     *\n     * Default is `constant_score`.\n     *\n     * Note: The deprecated multi term rewrite parameters `constant_score_auto`,\n     * `constant_score_filter` (synonyms for `constant_score`) have been removed\n     * in elasticsearch 6.0.\n     *\n     * This is an advanced option, use with care.\n     *\n     * @param {string} method The rewrite method as a string.\n     * @returns {MatchQuery} returns `this` so that calls can be chained.\n     * @throws {Error} If the given `rewrite` method is not valid.\n     */\n\n  }, {\n    key: 'rewrite',\n    value: function rewrite(method) {\n      validateRewiteMethod(method, 'rewrite', ES_REF_URL);\n      this._queryOpts.rewrite = method;\n      return this;\n    }\n    /**\n     * Sets the fuzzy rewrite method. Valid values are:\n     * - `constant_score` - tries to pick the best constant-score rewrite\n     *  method based on term and document counts from the query.\n     *  Synonyms - `constant_score_auto`, `constant_score_filter`\n     *\n     * - `scoring_boolean` - translates each term into boolean should and\n     *  keeps the scores as computed by the query\n     *\n     * - `constant_score_boolean` - same as `scoring_boolean`, expect no scores\n     *  are computed.\n     *\n     * - `constant_score_filter` - first creates a private Filter, by visiting\n     *  each term in sequence and marking all docs for that term\n     *\n     * - `top_terms_boost_N` - first translates each term into boolean should\n     *  and scores are only computed as the boost using the top N\n     *  scoring terms. Replace N with an integer value.\n     *\n     * - `top_terms_N` - first translates each term into boolean should\n     *  and keeps the scores as computed by the query. Only the top N\n     *  scoring terms are used. Replace N with an integer value.\n     *\n     * Default is `constant_score`.\n     *\n     * This is an advanced option, use with care.\n     *\n     * Note: The deprecated multi term rewrite parameters `constant_score_auto`,\n     * `constant_score_filter` (synonyms for `constant_score`) have been removed\n     * in elasticsearch 6.0.\n     *\n     * @param {string} method The rewrite method as a string.\n     * @returns {MatchQuery} returns `this` so that calls can be chained.\n     * @throws {Error} If the given `fuzzy_rewrite` method is not valid.\n     */\n\n  }, {\n    key: 'fuzzyRewrite',\n    value: function fuzzyRewrite(method) {\n      validateRewiteMethod(method, 'fuzzy_rewrite', ES_REF_URL);\n      this._queryOpts.fuzzy_rewrite = method;\n      return this;\n    }\n    /**\n     * Fuzzy transpositions (`ab` → `ba`) are allowed by default but can be disabled\n     * by setting `fuzzy_transpositions` to false.\n     * @param {boolean} enable\n     * @returns {MatchQuery} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'fuzzyTranspositions',\n    value: function fuzzyTranspositions(enable) {\n      this._queryOpts.fuzzy_transpositions = enable;\n      return this;\n    }\n    /**\n     * If the analyzer used removes all tokens in a query like a `stop` filter does,\n     * the default behavior is to match no documents at all. In order to change that\n     * the `zero_terms_query` option can be used, which accepts `none` (default) and `all`\n     * which corresponds to a `match_all` query.\n     *\n     * @example\n     * const qry = esb.matchQuery('message', 'to be or not to be')\n     *     .operator('and')\n     *     .zeroTermsQuery('all');\n     *\n     * @param {string} behavior A no match action, `all` or `none`. Default is `none`.\n     * @returns {MatchQuery} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'zeroTermsQuery',\n    value: function zeroTermsQuery(behavior) {\n      if (isNil(behavior)) invalidZeroTermsQueryParam(behavior);\n      var behaviorLower = behavior.toLowerCase();\n\n      if (behaviorLower !== 'all' && behaviorLower !== 'none') {\n        invalidZeroTermsQueryParam(behavior);\n      }\n\n      this._queryOpts.zero_terms_query = behaviorLower;\n      return this;\n    }\n    /**\n     * Allows specifying an absolute or relative document frequency where high frequency\n     * terms are moved into an optional subquery and are only scored if one of the\n     * low frequency (below the cutoff) terms in the case of an `or` operator or\n     * all of the low frequency terms in the case of an `and` operator match.\n     *\n     * @example\n     * const qry = esb.matchQuery('message', 'to be or not to be')\n     *     .cutoffFrequency(0.001);\n     *\n     * @param {number} frequency It can either be relative to the total number of documents\n     * if in the range `[0..1)` or absolute if greater or equal to `1.0`.\n     * @returns {MatchQuery} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'cutoffFrequency',\n    value: function cutoffFrequency(frequency) {\n      this._queryOpts.cutoff_frequency = frequency;\n      return this;\n    }\n  }]);\n  return MatchQuery;\n}(MonoFieldQueryBase);\n\nmodule.exports = MatchQuery;","map":null,"metadata":{},"sourceType":"script"}