{"ast":null,"code":"'use strict';\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = require('babel-runtime/helpers/inherits');\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar QueryStringQueryBase = require('./query-string-query-base');\n\nvar _require = require('../helper'),\n    validateRewiteMethod = _require.validateRewiteMethod;\n\nvar ES_REF_URL = 'https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-query-string-query.html';\n/**\n * A query that uses a query parser in order to parse its content.\n *\n * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-query-string-query.html)\n *\n * @example\n * const qry = esb.queryStringQuery('this AND that OR thus')\n *     .defaultField('content');\n *\n * @param {string=} queryString The actual query to be parsed.\n *\n * @extends QueryStringQueryBase\n */\n\nvar QueryStringQuery = function (_QueryStringQueryBase) {\n  (0, _inherits3.default)(QueryStringQuery, _QueryStringQueryBase); // eslint-disable-next-line require-jsdoc\n\n  function QueryStringQuery(queryString) {\n    (0, _classCallCheck3.default)(this, QueryStringQuery);\n    return (0, _possibleConstructorReturn3.default)(this, (QueryStringQuery.__proto__ || Object.getPrototypeOf(QueryStringQuery)).call(this, 'query_string', ES_REF_URL, queryString));\n  }\n  /**\n   * The default field for query terms if no prefix field is specified.\n   * Defaults to the `index.query.default_field` index settings, which\n   * in turn defaults to `_all`.\n   *\n   * @param {string} field\n   * @returns {QueryStringQuery} returns `this` so that calls can be chained.\n   */\n\n\n  (0, _createClass3.default)(QueryStringQuery, [{\n    key: 'defaultField',\n    value: function defaultField(field) {\n      this._queryOpts.default_field = field;\n      return this;\n    }\n    /**\n     * When set, `*` or `?` are allowed as the first character. Defaults to `true`.\n     *\n     * @param {boolean} enable\n     * @returns {QueryStringQuery} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'allowLeadingWildcard',\n    value: function allowLeadingWildcard(enable) {\n      this._queryOpts.allow_leading_wildcard = enable;\n      return this;\n    }\n    /**\n     * Set to true to enable position increments in result queries. Defaults to true.\n     *\n     * @param {boolean} enable\n     * @returns {QueryStringQuery} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'enablePositionIncrements',\n    value: function enablePositionIncrements(enable) {\n      this._queryOpts.enable_position_increments = enable;\n      return this;\n    }\n    /**\n     * Controls the number of terms fuzzy queries will expand to. Defaults to `50`.\n     *\n     * @param {number} limit\n     * @returns {QueryStringQuery} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'fuzzyMaxExpansions',\n    value: function fuzzyMaxExpansions(limit) {\n      this._queryOpts.fuzzy_max_expansions = limit;\n      return this;\n    }\n    /**\n     * Sets the `fuzziness` parameter which is interpreted as a Levenshtein Edit Distance —\n     * the number of one character changes that need to be made to one string to make it\n     * the same as another string. Defaults to `AUTO`.\n     *\n     * @param {number|string} factor Can be specified either as a number, or the maximum\n     * number of edits, or as `AUTO` which generates an edit distance based on the length\n     * of the term. Defaults to `AUTO`.\n     * @returns {QueryStringQuery} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'fuzziness',\n    value: function fuzziness(factor) {\n      this._queryOpts.fuzziness = factor;\n      return this;\n    }\n    /**\n     * Set the prefix length for fuzzy queries. Default is `0`.\n     *\n     * @param {number} len\n     * @returns {QueryStringQuery} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'fuzzyPrefixLength',\n    value: function fuzzyPrefixLength(len) {\n      this._queryOpts.fuzzy_prefix_length = len;\n      return this;\n    }\n    /**\n     * Sets the rewrite method. Valid values are:\n     * - `constant_score` - tries to pick the best constant-score rewrite\n     *  method based on term and document counts from the query.\n     *  Synonyms - `constant_score_auto`, `constant_score_filter`\n     *\n     * - `scoring_boolean` - translates each term into boolean should and\n     *  keeps the scores as computed by the query\n     *\n     * - `constant_score_boolean` - same as `scoring_boolean`, expect no scores\n     *  are computed.\n     *\n     * - `constant_score_filter` - first creates a private Filter, by visiting\n     *  each term in sequence and marking all docs for that term\n     *\n     * - `top_terms_boost_N` - first translates each term into boolean should\n     *  and scores are only computed as the boost using the top N\n     *  scoring terms. Replace N with an integer value.\n     *\n     * - `top_terms_N` - first translates each term into boolean should\n     *  and keeps the scores as computed by the query. Only the top N\n     *  scoring terms are used. Replace N with an integer value.\n     *\n     * Default is `constant_score`.\n     *\n     * This is an advanced option, use with care.\n     *\n     * Note: The deprecated multi term rewrite parameters `constant_score_auto`,\n     * `constant_score_filter` (synonyms for `constant_score`) have been removed\n     * in elasticsearch 6.0.\n     *\n     * @param {string} method The rewrite method as a string.\n     * @returns {QueryStringQuery} returns `this` so that calls can be chained.\n     * @throws {Error} If the given `rewrite` method is not valid.\n     */\n\n  }, {\n    key: 'rewrite',\n    value: function rewrite(method) {\n      validateRewiteMethod(method, 'rewrite', ES_REF_URL);\n      this._queryOpts.rewrite = method;\n      return this;\n    }\n    /**\n     * Sets the fuzzy rewrite method. Valid values are:\n     * - `constant_score` - tries to pick the best constant-score rewrite\n     *  method based on term and document counts from the query.\n     *  Synonyms - `constant_score_auto`, `constant_score_filter`\n     *\n     * - `scoring_boolean` - translates each term into boolean should and\n     *  keeps the scores as computed by the query\n     *\n     * - `constant_score_boolean` - same as `scoring_boolean`, expect no scores\n     *  are computed.\n     *\n     * - `constant_score_filter` - first creates a private Filter, by visiting\n     *  each term in sequence and marking all docs for that term\n     *\n     * - `top_terms_boost_N` - first translates each term into boolean should\n     *  and scores are only computed as the boost using the top N\n     *  scoring terms. Replace N with an integer value.\n     *\n     * - `top_terms_N` - first translates each term into boolean should\n     *  and keeps the scores as computed by the query. Only the top N\n     *  scoring terms are used. Replace N with an integer value.\n     *\n     * Default is `constant_score`.\n     *\n     * This is an advanced option, use with care.\n     *\n     * Note: The deprecated multi term rewrite parameters `constant_score_auto`,\n     * `constant_score_filter` (synonyms for `constant_score`) have been removed\n     * in elasticsearch 6.0.\n     *\n     * @param {string} method The rewrite method as a string.\n     * @returns {QueryStringQuery} returns `this` so that calls can be chained.\n     * @throws {Error} If the given `fuzzy_rewrite` method is not valid.\n     */\n\n  }, {\n    key: 'fuzzyRewrite',\n    value: function fuzzyRewrite(method) {\n      validateRewiteMethod(method, 'fuzzy_rewrite', ES_REF_URL);\n      this._queryOpts.fuzzy_rewrite = method;\n      return this;\n    }\n    /**\n     * Sets the default slop for phrases. If zero, then exact phrase matches are required.\n     * Default value is 0.\n     *\n     * @param {number} slop A positive integer value, defaults is 0.\n     * @returns {QueryStringQuery} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'phraseSlop',\n    value: function phraseSlop(slop) {\n      this._queryOpts.phrase_slop = slop;\n      return this;\n    }\n    /**\n     * Auto generate phrase queries. Defaults to `false`.\n     *\n     * Note: This parameter has been removed in elasticsearch 6.0. If provided,\n     * it will be ignored and issue a deprecation warning.\n     *\n     * @param {boolean} enable\n     * @returns {QueryStringQuery} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'autoGeneratePhraseQueries',\n    value: function autoGeneratePhraseQueries(enable) {\n      this._queryOpts.auto_generate_phrase_queries = enable;\n      return this;\n    }\n    /**\n     * Limit on how many automaton states regexp queries are allowed to create.\n     * This protects against too-difficult (e.g. exponentially hard) regexps.\n     * Defaults to 10000.\n     *\n     * @param {number} limit\n     * @returns {QueryStringQuery} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'maxDeterminizedStates',\n    value: function maxDeterminizedStates(limit) {\n      this._queryOpts.max_determinized_states = limit;\n      return this;\n    }\n    /**\n     * Time Zone to be applied to any range query related to dates.\n     *\n     * @param {string} zone\n     * @returns {QueryStringQuery} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'timeZone',\n    value: function timeZone(zone) {\n      this._queryOpts.time_zone = zone;\n      return this;\n    }\n    /**\n     * Whether query text should be split on whitespace prior to analysis.\n     * Instead the queryparser would parse around only real operators.\n     * Default is `false`. It is not allowed to set this option to `false`\n     * if `auto_generate_phrase_queries` is already set to `true`.\n     *\n     * Note: This parameter has been removed in elasticsearch 6.0. If provided,\n     * it will be ignored and issue a deprecation warning. The `query_string`\n     * query now splits on operator only.\n     *\n     * @param {string} enable\n     * @returns {QueryStringQuery} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'splitOnWhitespace',\n    value: function splitOnWhitespace(enable) {\n      this._queryOpts.split_on_whitespace = enable;\n      return this;\n    }\n    /**\n     * Should the queries be combined using `dis_max` (set it to `true`),\n     * or a bool query (set it to `false`). Defaults to `true`.\n     *\n     * Note: This parameter has been removed in elasticsearch 6.0. If provided,\n     * it will be ignored and issue a deprecation warning. The `tie_breaker`\n     * parameter must be used instead.\n     *\n     * @example\n     * const qry = esb.queryStringQuery('this AND that OR thus')\n     *     .fields(['content', 'name^5'])\n     *     .useDisMax(true);\n     *\n     * @param {boolean} enable\n     * @returns {QueryStringQuery} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'useDisMax',\n    value: function useDisMax(enable) {\n      this._queryOpts.use_dis_max = enable;\n      return this;\n    }\n    /**\n     * When using `dis_max`, the disjunction max tie breaker. Defaults to `0`.\n     *\n     * @param {number} factor\n     * @returns {QueryStringQuery} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'tieBreaker',\n    value: function tieBreaker(factor) {\n      this._queryOpts.tie_breaker = factor;\n      return this;\n    }\n    /**\n     * Sets the quote analyzer name used to analyze the `query`\n     * when in quoted text.\n     *\n     * @param {string} analyzer A valid analyzer name.\n     * @returns {QueryStringQuery} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'quoteAnalyzer',\n    value: function quoteAnalyzer(analyzer) {\n      this._queryOpts.quote_analyzer = analyzer;\n      return this;\n    }\n    /**\n     * If they query string should be escaped or not.\n     *\n     * @param {boolean} enable\n     * @returns {QueryStringQuery} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'escape',\n    value: function escape(enable) {\n      this._queryOpts.escape = enable;\n      return this;\n    }\n  }]);\n  return QueryStringQuery;\n}(QueryStringQueryBase);\n\nmodule.exports = QueryStringQuery;","map":null,"metadata":{},"sourceType":"script"}