{"ast":null,"code":"'use strict';\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = require('babel-runtime/helpers/inherits');\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar isNil = require('lodash.isnil');\n\nvar _require = require('../../core'),\n    _require$util = _require.util,\n    checkType = _require$util.checkType,\n    invalidParam = _require$util.invalidParam,\n    MULTI_MATCH_TYPE = _require.consts.MULTI_MATCH_TYPE;\n\nvar FullTextQueryBase = require('./full-text-query-base');\n\nvar _require2 = require('../helper'),\n    validateRewiteMethod = _require2.validateRewiteMethod;\n\nvar ES_REF_URL = 'https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-multi-match-query.html';\nvar invalidTypeParam = invalidParam(ES_REF_URL, 'type', MULTI_MATCH_TYPE);\nvar invalidOperatorParam = invalidParam(ES_REF_URL, 'operator', \"'and' or 'or'\");\nvar invalidBehaviorParam = invalidParam(ES_REF_URL, 'behavior', \"'all' or 'none'\");\n/**\n * A `MultiMatchQuery` query builds further on top of the\n * `MultiMatchQuery` by allowing multiple fields to be specified.\n * The idea here is to allow to more easily build a concise match type query\n * over multiple fields instead of using a relatively more expressive query\n * by using multiple match queries within a bool query.\n *\n * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-multi-match-query.html)\n *\n * @example\n * const qry = esb.multiMatchQuery(['subject', 'message'], 'this is a test');\n *\n * @param {Array<string>|string=} fields The fields to be queried\n * @param {string=} queryString The query string\n *\n * @extends FullTextQueryBase\n */\n\nvar MultiMatchQuery = function (_FullTextQueryBase) {\n  (0, _inherits3.default)(MultiMatchQuery, _FullTextQueryBase); // Extremely similar to match query.\n  // mixins are one way to go about it.\n  // repeating code for now\n  // eslint-disable-next-line require-jsdoc\n\n  function MultiMatchQuery(fields, queryString) {\n    (0, _classCallCheck3.default)(this, MultiMatchQuery); // This field is required\n    // Avoid checking for key in `this.field`\n\n    var _this = (0, _possibleConstructorReturn3.default)(this, (MultiMatchQuery.__proto__ || Object.getPrototypeOf(MultiMatchQuery)).call(this, 'multi_match', queryString));\n\n    _this._queryOpts.fields = [];\n\n    if (!isNil(fields)) {\n      if (Array.isArray(fields)) _this.fields(fields);else _this.field(fields);\n    }\n\n    return _this;\n  }\n  /**\n   * Appends given field to the list of fields to search against.\n   * Fields can be specified with wildcards.\n   * Individual fields can be boosted with the caret (^) notation.\n   * Example - `\"subject^3\"`\n   *\n   * @param {string} field One of the fields to be queried\n   * @returns {MultiMatchQuery} returns `this` so that calls can be chained.\n   */\n\n\n  (0, _createClass3.default)(MultiMatchQuery, [{\n    key: 'field',\n    value: function field(_field) {\n      this._queryOpts.fields.push(_field);\n\n      return this;\n    }\n    /**\n     * Appends given fields to the list of fields to search against.\n     * Fields can be specified with wildcards.\n     * Individual fields can be boosted with the caret (^) notation.\n     *\n     * @example\n     * // Boost individual fields with caret `^` notation\n     * const qry = esb.multiMatchQuery(['subject^3', 'message'], 'this is a test');\n     *\n     * @example\n     * // Specify fields with wildcards\n     *const qry = esb.multiMatchQuery(['title', '*_name'], 'Will Smith');\n     *\n     * @param {Array<string>} fields The fields to be queried\n     * @returns {MultiMatchQuery} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'fields',\n    value: function fields(_fields) {\n      checkType(_fields, Array);\n      this._queryOpts.fields = this._queryOpts.fields.concat(_fields);\n      return this;\n    }\n    /**\n     * Sets the type of multi match query. Valid values are:\n     * - `best_fields` - (default) Finds documents which match any field,\n     * but uses the `_score` from the best field.\n     *\n     * - `most_fields` - Finds documents which match any field and combines\n     * the `_score` from each field.\n     *\n     * - `cross_fields` - Treats fields with the same `analyzer` as though\n     * they were one big field. Looks for each word in *any* field\n     *\n     * - `phrase` - Runs a `match_phrase` query on each field and combines\n     * the `_score` from each field.\n     *\n     * - `phrase_prefix` - Runs a `match_phrase_prefix` query on each field\n     * and combines the `_score` from each field.\n     *\n     * @example\n     * // Find the single best matching field\n     * const qry = esb.multiMatchQuery(['subject', 'message'], 'brown fox')\n     *     .type('best_fields')\n     *     .tieBreaker(0.3);\n     *\n     * @example\n     * // Query multiple fields analyzed differently for the same text\n     * const qry = esb.multiMatchQuery(\n     *     ['title', 'title.original', 'title.shingles'],\n     *     'quick brown fox'\n     * ).type('most_fields');\n     *\n     * @example\n     * // Run a `match_phrase_prefix` query on multiple fields\n     * const qry = esb.multiMatchQuery(\n     *     ['subject', 'message'],\n     *     'quick brown f'\n     * ).type('phrase_prefix');\n     *\n     * @example\n     * // All terms must be present in at least one field for document to match\n     * const qry = esb.multiMatchQuery(['first_name', 'last_name'], 'Will Smith')\n     *     .type('cross_fields')\n     *     .operator('and');\n     *\n     * @param {string} type Can be one of `best_fields`, `most_fields`,\n     * `cross_fields`, `phrase`, and `phrase_prefix`. Default is `best_fields`.\n     * @returns {MultiMatchQuery} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'type',\n    value: function type(_type) {\n      if (isNil(_type)) invalidTypeParam(_type);\n\n      var typeLower = _type.toLowerCase();\n\n      if (!MULTI_MATCH_TYPE.has(typeLower)) invalidTypeParam(_type);\n      this._queryOpts.type = typeLower;\n      return this;\n    }\n    /**\n     * The tie breaker value. The tie breaker capability allows results\n     * that include the same term in multiple fields to be judged better than\n     * results that include this term in only the best of those multiple\n     * fields, without confusing this with the better case of two different\n     * terms in the multiple fields. Default: `0.0`.\n     *\n     * @param {number} factor\n     * @returns {MultiMatchQuery} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'tieBreaker',\n    value: function tieBreaker(factor) {\n      this._queryOpts.tie_breaker = factor;\n      return this;\n    }\n    /**\n     * The operator to be used in the boolean query which is constructed\n     * by analyzing the text provided. The `operator` flag can be set to `or` or\n     * `and` to control the boolean clauses (defaults to `or`).\n     *\n     * @param {string} operator Can be `and`/`or`. Default is `or`.\n     * @returns {MultiMatchQuery} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'operator',\n    value: function operator(_operator) {\n      if (isNil(_operator)) invalidOperatorParam(_operator);\n\n      var operatorLower = _operator.toLowerCase();\n\n      if (operatorLower !== 'and' && operatorLower !== 'or') {\n        invalidOperatorParam(_operator);\n      }\n\n      this._queryOpts.operator = operatorLower;\n      return this;\n    }\n    /**\n     * Sets the `lenient` parameter which allows to ignore exceptions caused\n     * by data-type mismatches such as trying to query a numeric field with a\n     * text query string when set to `true`.\n     *\n     * @param {boolean} enable Defaules to `false`\n     * @returns {MultiMatchQuery} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'lenient',\n    value: function lenient(enable) {\n      this._queryOpts.lenient = enable;\n      return this;\n    } // phrase_slop is a synonym for slop.\n    // haven't added method for it..\n\n    /**\n     * Configures the `slop`(default is 0) for matching terms in any order.\n     * Transposed terms have a slop of 2.\n     *\n     * @param {number} slop A positive integer value, defaults is 0.\n     * @returns {MultiMatchQuery} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'slop',\n    value: function slop(_slop) {\n      this._queryOpts.slop = _slop;\n      return this;\n    }\n    /**\n     * Sets the `fuzziness` parameter which is interpreted as a Levenshtein Edit Distance —\n     * the number of one character changes that need to be made to one string to make it\n     * the same as another string.\n     *\n     * The `fuzziness` parameter cannot be used with the `phrase`, `phrase_prefix`\n     * or `cross_fields` type.\n     *\n     * @param {number|string} factor Can be specified either as a number, or the maximum\n     * number of edits, or as `AUTO` which generates an edit distance based on the length\n     * of the term.\n     * @returns {MultiMatchQuery} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'fuzziness',\n    value: function fuzziness(factor) {\n      this._queryOpts.fuzziness = factor;\n      return this;\n    }\n    /**\n     * Sets the prefix length for a fuzzy prefix `MultiMatchQuery`\n     *\n     * @param {number} len\n     * @returns {MultiMatchQuery} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'prefixLength',\n    value: function prefixLength(len) {\n      this._queryOpts.prefix_length = len;\n      return this;\n    }\n    /**\n     * Sets the max expansions for a fuzzy prefix `MultiMatchQuery`\n     *\n     * @param {number} limit\n     * @returns {MultiMatchQuery} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'maxExpansions',\n    value: function maxExpansions(limit) {\n      this._queryOpts.max_expansions = limit;\n      return this;\n    }\n    /**\n     * Sets the rewrite method. Valid values are:\n     * - `constant_score` - tries to pick the best constant-score rewrite\n     *  method based on term and document counts from the query.\n     *  Synonyms - `constant_score_auto`, `constant_score_filter`\n     *\n     * - `scoring_boolean` - translates each term into boolean should and\n     *  keeps the scores as computed by the query\n     *\n     * - `constant_score_boolean` - same as `scoring_boolean`, expect no scores\n     *  are computed.\n     *\n     * - `constant_score_filter` - first creates a private Filter, by visiting\n     *  each term in sequence and marking all docs for that term\n     *\n     * - `top_terms_boost_N` - first translates each term into boolean should\n     *  and scores are only computed as the boost using the top N\n     *  scoring terms. Replace N with an integer value.\n     *\n     * - `top_terms_N` - first translates each term into boolean should\n     *  and keeps the scores as computed by the query. Only the top N\n     *  scoring terms are used. Replace N with an integer value.\n     *\n     * Default is `constant_score`.\n     *\n     * This is an advanced option, use with care.\n     *\n     * Note: The deprecated multi term rewrite parameters `constant_score_auto`,\n     * `constant_score_filter` (synonyms for `constant_score`) have been removed\n     * in elasticsearch 6.0.\n     *\n     * @param {string} method The rewrite method as a string.\n     * @returns {MultiMatchQuery} returns `this` so that calls can be chained.\n     * @throws {Error} If the given `rewrite` method is not valid.\n     */\n\n  }, {\n    key: 'rewrite',\n    value: function rewrite(method) {\n      validateRewiteMethod(method, 'rewrite', ES_REF_URL);\n      this._queryOpts.rewrite = method;\n      return this;\n    }\n    /**\n     * Sets the fuzzy rewrite method. Valid values are:\n     * - `constant_score` - tries to pick the best constant-score rewrite\n     *  method based on term and document counts from the query.\n     *  Synonyms - `constant_score_auto`, `constant_score_filter`\n     *\n     * - `scoring_boolean` - translates each term into boolean should and\n     *  keeps the scores as computed by the query\n     *\n     * - `constant_score_boolean` - same as `scoring_boolean`, expect no scores\n     *  are computed.\n     *\n     * - `constant_score_filter` - first creates a private Filter, by visiting\n     *  each term in sequence and marking all docs for that term\n     *\n     * - `top_terms_boost_N` - first translates each term into boolean should\n     *  and scores are only computed as the boost using the top N\n     *  scoring terms. Replace N with an integer value.\n     *\n     * - `top_terms_N` - first translates each term into boolean should\n     *  and keeps the scores as computed by the query. Only the top N\n     *  scoring terms are used. Replace N with an integer value.\n     *\n     * Default is `constant_score`.\n     *\n     * This is an advanced option, use with care.\n     *\n     * Note: The deprecated multi term rewrite parameters `constant_score_auto`,\n     * `constant_score_filter` (synonyms for `constant_score`) have been removed\n     * in elasticsearch 6.0.\n     *\n     * @param {string} method The rewrite method as a string.\n     * @returns {MultiMatchQuery} returns `this` so that calls can be chained.\n     * @throws {Error} If the given `fuzzy_rewrite` method is not valid.\n     */\n\n  }, {\n    key: 'fuzzyRewrite',\n    value: function fuzzyRewrite(method) {\n      validateRewiteMethod(method, 'fuzzy_rewrite', ES_REF_URL);\n      this._queryOpts.fuzzy_rewrite = method;\n      return this;\n    }\n    /**\n     * If the analyzer used removes all tokens in a query like a `stop` filter does,\n     * the default behavior is to match no documents at all. In order to change that\n     * the `zero_terms_query` option can be used, which accepts `none` (default) and `all`\n     * which corresponds to a `match_all` query.\n     *\n     * @param {string} behavior A no match action, `all` or `none`. Default is `none`.\n     * @returns {MultiMatchQuery} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'zeroTermsQuery',\n    value: function zeroTermsQuery(behavior) {\n      if (isNil(behavior)) invalidBehaviorParam(behavior);\n      var behaviorLower = behavior.toLowerCase();\n\n      if (behaviorLower !== 'all' && behaviorLower !== 'none') {\n        invalidBehaviorParam(behavior);\n      }\n\n      this._queryOpts.zero_terms_query = behavior;\n      return this;\n    }\n    /**\n     * Allows specifying an absolute or relative document frequency where high frequency\n     * terms are moved into an optional subquery and are only scored if one of the\n     * low frequency (below the cutoff) terms in the case of an `or` operator or\n     * all of the low frequency terms in the case of an `and` operator match.\n     *\n     * @param {number} frequency It can either be relative to the total number of documents\n     * if in the range `[0..1)` or absolute if greater or equal to `1.0`.\n     * @returns {MultiMatchQuery} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'cutoffFrequency',\n    value: function cutoffFrequency(frequency) {\n      this._queryOpts.cutoff_frequency = frequency;\n      return this;\n    }\n  }]);\n  return MultiMatchQuery;\n}(FullTextQueryBase);\n\nmodule.exports = MultiMatchQuery;","map":null,"metadata":{},"sourceType":"script"}