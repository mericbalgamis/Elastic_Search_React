{"ast":null,"code":"'use strict';\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = require('babel-runtime/helpers/inherits');\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar isNil = require('lodash.isnil');\n\nvar _require = require('../../core'),\n    invalidParam = _require.util.invalidParam,\n    EXECUTION_HINT_SET = _require.consts.EXECUTION_HINT_SET;\n\nvar BucketAggregationBase = require('./bucket-aggregation-base');\n\nvar invalidExecutionHintParam = invalidParam('', 'execution_hint', EXECUTION_HINT_SET);\n/**\n * The `TermsAggregationBase` provides support for common options used across\n * various terms `Aggregation` implementations like Significant terms and\n * Terms aggregation.\n *\n * **NOTE:** Instantiating this directly should not be required.\n * However, if you wish to add a custom implementation for whatever reason,\n * this class could be extended.\n *\n * @param {string} name The name which will be used to refer to this aggregation.\n * @param {string} aggType Type of aggregation\n * @param {string} refUrl Elasticsearch reference URL.\n * @param {string=} field The field to aggregate on\n *\n * @extends BucketAggregationBase\n */\n\nvar TermsAggregationBase = function (_BucketAggregationBas) {\n  (0, _inherits3.default)(TermsAggregationBase, _BucketAggregationBas); // eslint-disable-next-line require-jsdoc\n\n  function TermsAggregationBase(name, aggType, refUrl, field) {\n    (0, _classCallCheck3.default)(this, TermsAggregationBase);\n\n    var _this = (0, _possibleConstructorReturn3.default)(this, (TermsAggregationBase.__proto__ || Object.getPrototypeOf(TermsAggregationBase)).call(this, name, aggType, field));\n\n    _this._refUrl = refUrl;\n    return _this;\n  }\n  /**\n   * Sets the format expression for `key_as_string` in response buckets.\n   * If no format is specified, then it will use the first format specified in the field mapping.\n   *\n   * @param {string} fmt Format mask to apply on aggregation response. Example: ####.00.\n   * @returns {TermsAggregationBase} returns `this` so that calls can be chained\n   */\n\n\n  (0, _createClass3.default)(TermsAggregationBase, [{\n    key: 'format',\n    value: function format(fmt) {\n      this._aggsDef.format = fmt;\n      return this;\n    }\n    /**\n     * Sets the minimum number of matching hits required to return the terms.\n     *\n     * @example\n     * const agg = esb.significantTermsAggregation('tags', 'tag').minDocCount(10);\n     *\n     * @param {number} minDocCnt Integer value for minimum number of documents\n     * required to return bucket in response\n     * @returns {TermsAggregationBase} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'minDocCount',\n    value: function minDocCount(minDocCnt) {\n      this._aggsDef.min_doc_count = minDocCnt;\n      return this;\n    }\n    /**\n     * Sets the parameter which regulates the _certainty_ a shard has if the term\n     * should actually be added to the candidate list or not with respect to\n     * the `min_doc_count`.\n     * Terms will only be considered if their local shard frequency within\n     * the set is higher than the `shard_min_doc_count`.\n     *\n     * @param {number} minDocCnt Sets the `shard_min_doc_count` parameter. Default is 1\n     * and has no effect unless you explicitly set it.\n     * @returns {TermsAggregationBase} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'shardMinDocCount',\n    value: function shardMinDocCount(minDocCnt) {\n      this._aggsDef.shard_min_doc_count = minDocCnt;\n      return this;\n    }\n    /**\n     * Defines how many term buckets should be returned out of the overall terms list.\n     *\n     * @example\n     * const agg = esb.termsAggregation('products', 'product').size(5);\n     *\n     * @param {number} size\n     * @returns {TermsAggregationBase} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'size',\n    value: function size(_size) {\n      this._aggsDef.size = _size;\n      return this;\n    }\n    /**\n     * Sets the `shard_size` parameter to control the volumes of candidate terms\n     * produced by each shard. For the default, -1, shard_size will be automatically\n     * estimated based on the number of shards and the size parameter.\n     *\n     * `shard_size` cannot be smaller than size (as it doesnâ€™t make much sense).\n     * When it is, elasticsearch will override it and reset it to be equal to size.\n     *\n     * @param {number} size\n     * @returns {TermsAggregationBase} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'shardSize',\n    value: function shardSize(size) {\n      this._aggsDef.shard_size = size;\n      return this;\n    }\n    /**\n     * Sets the missing parameter which defines how documents\n     * that are missing a value should be treated.\n     *\n     * @param {string} value\n     * @returns {TermsAggregationBase} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'missing',\n    value: function missing(value) {\n      this._aggsDef.missing = value;\n      return this;\n    }\n    /**\n     * Filter the values for which buckets will be created.\n     *\n     * @example\n     * const agg = esb.termsAggregation('tags', 'tags')\n     *     .include('.*sport.*')\n     *     .exclude('water_.*');\n     *\n     * @example\n     * // Match on exact values\n     * const reqBody = esb.requestBodySearch()\n     *     .agg(\n     *         esb.termsAggregation('JapaneseCars', 'make').include([\n     *             'mazda',\n     *             'honda'\n     *         ])\n     *     )\n     *     .agg(\n     *         esb.termsAggregation('ActiveCarManufacturers', 'make').exclude([\n     *             'rover',\n     *             'jensen'\n     *         ])\n     *     );\n     *\n     * @param {RegExp|Array|string} clause Determine what values are \"allowed\" to be aggregated\n     * @returns {TermsAggregationBase} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'include',\n    value: function include(clause) {\n      this._aggsDef.include = clause;\n      return this;\n    }\n    /**\n     * Filter the values for which buckets will be created.\n     *\n     * @example\n     * const agg = esb.termsAggregation('tags', 'tags')\n     *     .include('.*sport.*')\n     *     .exclude('water_.*');\n     *\n     * @example\n     * // Match on exact values\n     * const reqBody = esb.requestBodySearch()\n     *     .agg(\n     *         esb.termsAggregation('JapaneseCars', 'make').include([\n     *             'mazda',\n     *             'honda'\n     *         ])\n     *     )\n     *     .agg(\n     *         esb.termsAggregation('ActiveCarManufacturers', 'make').exclude([\n     *             'rover',\n     *             'jensen'\n     *         ])\n     *     );\n     *\n     * @param {RegExp|Array|string} clause Determine the values that should not be aggregated\n     * @returns {TermsAggregationBase} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'exclude',\n    value: function exclude(clause) {\n      this._aggsDef.exclude = clause;\n      return this;\n    }\n    /**\n     * This setting can influence the management of the values used\n     * for de-duplication. Each option will hold up to shard_size\n     * values in memory while performing de-duplication but\n     * the type of value held can be controlled\n     *\n     * @example\n     * const agg = esb.significantTermsAggregation('tags', 'tag').executionHint('map');\n     *\n     * @example\n     * const agg = esb.termsAggregation('tags', 'tags').executionHint('map');\n     *\n     * @param {string} hint the possible values are `map`, `global_ordinals`,\n     * `global_ordinals_hash` and `global_ordinals_low_cardinality`\n     * @returns {TermsAggregationBase} returns `this` so that calls can be chained\n     * @throws {Error} If Execution Hint is outside the accepted set.\n     */\n\n  }, {\n    key: 'executionHint',\n    value: function executionHint(hint) {\n      if (isNil(hint)) invalidExecutionHintParam(hint, this._refUrl);\n      var hintLower = hint.toLowerCase();\n\n      if (!EXECUTION_HINT_SET.has(hintLower)) {\n        invalidExecutionHintParam(hint, this._refUrl);\n      }\n\n      this._aggsDef.execution_hint = hint;\n      return this;\n    }\n  }]);\n  return TermsAggregationBase;\n}(BucketAggregationBase);\n\nmodule.exports = TermsAggregationBase;","map":null,"metadata":{},"sourceType":"script"}