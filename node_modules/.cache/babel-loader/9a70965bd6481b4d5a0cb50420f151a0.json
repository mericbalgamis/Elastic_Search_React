{"ast":null,"code":"'use strict';\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar isNil = require('lodash.isnil');\n\nvar Query = require('./query');\n\nvar _require = require('./util'),\n    checkType = _require.checkType,\n    invalidParam = _require.invalidParam,\n    recursiveToJSON = _require.recursiveToJSON;\n\nvar _require2 = require('./consts'),\n    RESCORE_MODE_SET = _require2.RESCORE_MODE_SET;\n\nvar ES_REF_URL = 'https://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-rescore.html';\nvar invalidScoreModeParam = invalidParam(ES_REF_URL, 'score_mode', RESCORE_MODE_SET);\n/**\n * A `rescore` request can help to improve precision by reordering just\n * the top (eg 100 - 500) documents returned by the `query` and `post_filter`\n * phases, using a secondary (usually more costly) algorithm, instead of\n * applying the costly algorithm to all documents in the index.\n *\n * The rescore phase is not executed when sort is used.\n *\n * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-rescore.html)\n *\n * @example\n * const reqBody = esb.requestBodySearch()\n *     .query(esb.matchQuery('message', 'the quick brown').operator('or'))\n *     .rescore(\n *         esb.rescore(\n *             50,\n *             esb.matchPhraseQuery('message', 'the quick brown').slop(2)\n *         )\n *             .queryWeight(0.7)\n *             .rescoreQueryWeight(1.2)\n *     );\n *\n * @example\n * const rescore = esb.rescore(\n *     10,\n *     esb.functionScoreQuery().function(\n *         esb.scriptScoreFunction(\n *             esb.script('inline', 'Math.log10(doc.likes.value + 2)')\n *         )\n *     )\n * ).scoreMode('multiply');\n *\n * @param {number=} windowSize\n * @param {Query=} rescoreQuery\n */\n\nvar Rescore = function () {\n  // eslint-disable-next-line require-jsdoc\n  function Rescore(windowSize, rescoreQuery) {\n    (0, _classCallCheck3.default)(this, Rescore);\n    this._body = {};\n    this._rescoreOpts = this._body.query = {};\n    if (!isNil(windowSize)) this._body.window_size = windowSize;\n    if (!isNil(rescoreQuery)) this.rescoreQuery(rescoreQuery);\n  }\n  /**\n   * The number of docs which will be examined on each shard can be controlled\n   * by the window_size parameter, which defaults to `from` and `size`.\n   *\n   * @param {number} windowSize\n   * @returns {Rescore} returns `this` so that calls can be chained.\n   */\n\n\n  (0, _createClass3.default)(Rescore, [{\n    key: 'windowSize',\n    value: function windowSize(_windowSize) {\n      this._body.window_size = _windowSize;\n      return this;\n    }\n    /**\n     * The query to execute on the Top-K results by the `query` and `post_filter` phases.\n     *\n     * @param {Query} rescoreQuery\n     * @returns {Rescore} returns `this` so that calls can be chained.\n     * @throws {TypeError} If `rescoreQuery` is not an instance of `Query`\n     */\n\n  }, {\n    key: 'rescoreQuery',\n    value: function rescoreQuery(_rescoreQuery) {\n      checkType(_rescoreQuery, Query);\n      this._rescoreOpts.rescore_query = _rescoreQuery;\n      return this;\n    }\n    /**\n     * Control the relative importance of the original query.\n     *\n     * @param {number} weight Defaults to 1\n     * @returns {Rescore} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'queryWeight',\n    value: function queryWeight(weight) {\n      this._rescoreOpts.query_weight = weight;\n      return this;\n    }\n    /**\n     * Control the relative importance of the rescore query.\n     *\n     * @param {number} weight Defaults to 1\n     * @returns {Rescore} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'rescoreQueryWeight',\n    value: function rescoreQueryWeight(weight) {\n      this._rescoreOpts.rescore_query_weight = weight;\n      return this;\n    }\n    /**\n     * Controls the way the scores are combined.\n     *\n     * @param {string} mode Can be one of `total`, `multiply`, `min`, `max`, `avg`.\n     * Defaults to `total`.\n     * @returns {Rescore} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'scoreMode',\n    value: function scoreMode(mode) {\n      if (isNil(mode)) invalidScoreModeParam(mode);\n      var modeLower = mode.toLowerCase();\n\n      if (!RESCORE_MODE_SET.has(modeLower)) {\n        invalidScoreModeParam(mode);\n      }\n\n      this._rescoreOpts.score_mode = modeLower;\n      return this;\n    }\n    /**\n     * Override default `toJSON` to return DSL representation for `rescore` request\n     *\n     * @override\n     * @returns {Object} returns an Object which maps to the elasticsearch query DSL\n     */\n\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return recursiveToJSON(this._body);\n    }\n  }]);\n  return Rescore;\n}();\n\nmodule.exports = Rescore;","map":null,"metadata":{},"sourceType":"script"}