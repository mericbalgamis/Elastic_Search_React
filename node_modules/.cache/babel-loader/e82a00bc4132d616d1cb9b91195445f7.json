{"ast":null,"code":"'use strict';\n\nvar _defineProperty2 = require('babel-runtime/helpers/defineProperty');\n\nvar _defineProperty3 = _interopRequireDefault(_defineProperty2);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = require('babel-runtime/helpers/inherits');\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar isNil = require('lodash.isnil');\n\nvar _require = require('../../core'),\n    checkType = _require.util.checkType;\n\nvar _require2 = require('../../core'),\n    Query = _require2.Query;\n/**\n * Filters documents that have fields that match any of the provided terms (**not analyzed**).\n *\n * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-terms-query.html)\n *\n * @example\n * const qry = esb.constantScoreQuery(\n *     esb.termsQuery('user', ['kimchy', 'elasticsearch'])\n * );\n *\n * @example\n * const qry = esb.termsQuery('user')\n *     .index('users')\n *     .type('user')\n *     .id(2)\n *     .path('followers');\n *\n * @param {string=} field\n * @param {Array|string|number|boolean=} values\n *\n * @extends Query\n */\n\n\nvar TermsQuery = function (_Query) {\n  (0, _inherits3.default)(TermsQuery, _Query); // TODO: The DSL is a mess. Think about cleaning up some.\n  // eslint-disable-next-line require-jsdoc\n\n  function TermsQuery(field, values) {\n    (0, _classCallCheck3.default)(this, TermsQuery); // Default assume user is not insane\n\n    var _this = (0, _possibleConstructorReturn3.default)(this, (TermsQuery.__proto__ || Object.getPrototypeOf(TermsQuery)).call(this, 'terms'));\n\n    _this._isTermsLookup = false;\n    _this._termsLookupOpts = {};\n    _this._values = [];\n    if (!isNil(field)) _this._field = field;\n\n    if (!isNil(values)) {\n      if (Array.isArray(values)) _this.values(values);else _this.value(values);\n    }\n\n    return _this;\n  }\n  /**\n   * Private helper function to set a terms lookup option.\n   *\n   * @private\n   * @param {string} key\n   * @param {string|number|boolean} val\n   */\n\n\n  (0, _createClass3.default)(TermsQuery, [{\n    key: '_setTermsLookupOpt',\n    value: function _setTermsLookupOpt(key, val) {\n      this._isTermsLookup = true;\n      this._termsLookupOpts[key] = val;\n    }\n    /**\n     * Sets the field to search on.\n     *\n     * @param {string} field\n     * @returns {TermsQuery} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'field',\n    value: function field(_field) {\n      this._field = _field;\n      return this;\n    }\n    /**\n     * Append given value to list of values to run Terms Query with.\n     *\n     * @param {string|number|boolean} value\n     * @returns {TermsQuery} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'value',\n    value: function value(_value) {\n      this._values.push(_value);\n\n      return this;\n    }\n    /**\n     * Specifies the values to run query for.\n     *\n     * @param {Array<string|number|boolean>} values Values to run query for.\n     * @returns {TermsQuery} returns `this` so that calls can be chained\n     * @throws {TypeError} If `values` is not an instance of Array\n     */\n\n  }, {\n    key: 'values',\n    value: function values(_values) {\n      checkType(_values, Array);\n      this._values = this._values.concat(_values);\n      return this;\n    }\n    /**\n     * Convenience method for setting term lookup options.\n     * Valid options are `index`, `type`, `id`, `path`and `routing`\n     *\n     * @param {Object} lookupOpts An object with any of the keys `index`,\n     * `type`, `id`, `path` and `routing`.\n     * @returns {TermsQuery} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'termsLookup',\n    value: function termsLookup(lookupOpts) {\n      checkType(lookupOpts, Object);\n      this._isTermsLookup = true;\n      Object.assign(this._termsLookupOpts, lookupOpts);\n      return this;\n    }\n    /**\n     * The index to fetch the term values from. Defaults to the current index.\n     *\n     * Note: The `index` parameter in the terms filter, used to look up terms in\n     * a dedicated index is mandatory in elasticsearch 6.0. Previously, the\n     * index defaulted to the index the query was executed on. In 6.0, this\n     * index must be explicitly set in the request.\n     *\n     * @param {string} idx The index to fetch the term values from.\n     * Defaults to the current index.\n     * @returns {TermsQuery} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'index',\n    value: function index(idx) {\n      this._setTermsLookupOpt('index', idx);\n\n      return this;\n    }\n    /**\n     * The type to fetch the term values from.\n     *\n     * @param {string} type\n     * @returns {TermsQuery} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'type',\n    value: function type(_type) {\n      this._setTermsLookupOpt('type', _type);\n\n      return this;\n    }\n    /**\n     * The id of the document to fetch the term values from.\n     *\n     * @param {string} id\n     * @returns {TermsQuery} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'id',\n    value: function id(_id) {\n      this._setTermsLookupOpt('id', _id);\n\n      return this;\n    }\n    /**\n     * The field specified as path to fetch the actual values for the `terms` filter.\n     *\n     * @param {string} path\n     * @returns {TermsQuery} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'path',\n    value: function path(_path) {\n      this._setTermsLookupOpt('path', _path);\n\n      return this;\n    }\n    /**\n     * A custom routing value to be used when retrieving the external terms doc.\n     *\n     * @param {string} routing\n     * @returns {TermsQuery} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'routing',\n    value: function routing(_routing) {\n      this._setTermsLookupOpt('routing', _routing);\n\n      return this;\n    }\n    /**\n     * Override default `toJSON` to return DSL representation of the `terms` query\n     * class instance.\n     *\n     * @override\n     * @returns {Object} returns an Object which maps to the elasticsearch query DSL\n     */\n\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      // recursiveToJSON doesn't seem to be required here.\n      return (0, _defineProperty3.default)({}, this.queryType, Object.assign({}, this._queryOpts, (0, _defineProperty3.default)({}, this._field, this._isTermsLookup ? this._termsLookupOpts : this._values)));\n    }\n  }]);\n  return TermsQuery;\n}(Query);\n\nmodule.exports = TermsQuery;","map":null,"metadata":{},"sourceType":"script"}