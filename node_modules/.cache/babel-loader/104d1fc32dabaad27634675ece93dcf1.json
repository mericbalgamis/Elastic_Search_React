{"ast":null,"code":"'use strict';\n\nvar _defineProperty2 = require('babel-runtime/helpers/defineProperty');\n\nvar _defineProperty3 = _interopRequireDefault(_defineProperty2);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = require('babel-runtime/helpers/inherits');\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar has = require('lodash.has');\n\nvar head = require('lodash.head');\n\nvar omit = require('lodash.omit');\n\nvar _require = require('../../core'),\n    Query = _require.Query,\n    _require$util = _require.util,\n    checkType = _require$util.checkType,\n    setDefault = _require$util.setDefault,\n    recursiveToJSON = _require$util.recursiveToJSON;\n/**\n * A query that matches documents matching boolean combinations of other queries.\n * The bool query maps to Lucene `BooleanQuery`. It is built using one or more\n * boolean clauses, each clause with a typed occurrence.\n *\n * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-bool-query.html)\n *\n * @example\n * const qry = esb.boolQuery()\n *     .must(esb.termQuery('user', 'kimchy'))\n *     .filter(esb.termQuery('tag', 'tech'))\n *     .mustNot(esb.rangeQuery('age').gte(10).lte(20))\n *     .should([\n *         esb.termQuery('tag', 'wow'),\n *         esb.termQuery('tag', 'elasticsearch')\n *     ])\n *     .minimumShouldMatch(1)\n *     .boost(1.0);\n *\n * @extends Query\n */\n\n\nvar BoolQuery = function (_Query) {\n  (0, _inherits3.default)(BoolQuery, _Query); // eslint-disable-next-line require-jsdoc\n\n  function BoolQuery() {\n    (0, _classCallCheck3.default)(this, BoolQuery);\n    return (0, _possibleConstructorReturn3.default)(this, (BoolQuery.__proto__ || Object.getPrototypeOf(BoolQuery)).call(this, 'bool'));\n  }\n  /**\n   * Add given query to list of queries under given clause.\n   *\n   * @private\n   * @param {string} clause\n   * @param {Query} query\n   * @throws {TypeError} If query is not an instance of `Query`\n   */\n\n\n  (0, _createClass3.default)(BoolQuery, [{\n    key: '_addQuery',\n    value: function _addQuery(clause, query) {\n      checkType(query, Query);\n\n      this._queryOpts[clause].push(query);\n    }\n    /**\n     * Add given query array or query to list of queries under given clause.\n     *\n     * @private\n     * @param {string} clause\n     * @param {Array<Query>|Query} queries List of valid `Query` objects or a `Query` object\n     * @throws {TypeError} If Array item or query is not an instance of `Query`\n     */\n\n  }, {\n    key: '_addQueries',\n    value: function _addQueries(clause, queries) {\n      var _this2 = this;\n\n      setDefault(this._queryOpts, clause, []);\n      if (Array.isArray(queries)) queries.forEach(function (qry) {\n        return _this2._addQuery(clause, qry);\n      });else this._addQuery(clause, queries);\n    }\n    /**\n     * Adds `must` query to boolean container.\n     * The clause (query) **must** appear in matching documents and will contribute to the score.\n     *\n     * @param {Array<Query>|Query} queries List of valid `Query` objects or a `Query` object\n     * @returns {BoolQuery} returns `this` so that calls can be chained.\n     * @throws {TypeError} If Array item or query is not an instance of `Query`\n     */\n\n  }, {\n    key: 'must',\n    value: function must(queries) {\n      this._addQueries('must', queries);\n\n      return this;\n    }\n    /**\n     * Adds `filter` query to boolean container.\n     * The clause (query) **must** appear in matching documents. However unlike `must` the score\n     * of the query will be ignored. Filter clauses are executed in filter context, meaning that\n     * scoring is ignored and clauses are considered for caching.\n     *\n     * @example\n     * // Assign score of `0` to all documents\n     * const qry = esb.boolQuery().filter(esb.termQuery('status', 'active'));\n     *\n     * // Assign a score of `1.0` to all documents\n     * const qry = esb.boolQuery()\n     *     .must(esb.matchAllQuery())\n     *     .filter(esb.termQuery('status', 'active'));\n     *\n     * @param {Array<Query>|Query} queries List of valid `Query` objects or a `Query` object\n     * @returns {BoolQuery} returns `this` so that calls can be chained.\n     * @throws {TypeError} If Array item or query is not an instance of `Query`\n     */\n\n  }, {\n    key: 'filter',\n    value: function filter(queries) {\n      this._addQueries('filter', queries);\n\n      return this;\n    }\n    /**\n     * Adds `must_not` query to boolean container.\n     * The clause (query) **must not** appear in the matching documents.\n     * Clauses are executed in filter context meaning that scoring is ignored\n     * and clauses are considered for caching. Because scoring is ignored,\n     * a score of 0 for all documents is returned.\n     *\n     * @param {Array<Query>|Query} queries List of valid `Query` objects or a `Query` object\n     * @returns {BoolQuery} returns `this` so that calls can be chained.\n     * @throws {TypeError} If Array item or query is not an instance of `Query`\n     */\n\n  }, {\n    key: 'mustNot',\n    value: function mustNot(queries) {\n      this._addQueries('must_not', queries);\n\n      return this;\n    }\n    /**\n     * Adds `should` query to boolean container.\n     * The clause (query) **should** appear in the matching document. In a boolean query with\n     * no must or filter clauses, one or more should clauses must match a document.\n     * The minimum number of should clauses to match can be set using the\n     * `minimum_should_match` parameter.\n     *\n     * @param {Array<Query>|Query} queries List of valid `Query` objects or a `Query` object\n     * @returns {BoolQuery} returns `this` so that calls can be chained.\n     * @throws {TypeError} If Array item or query is not an instance of `Query`\n     */\n\n  }, {\n    key: 'should',\n    value: function should(queries) {\n      this._addQueries('should', queries);\n\n      return this;\n    }\n    /**\n     * Enables or disables similarity coordinate scoring of documents\n     * commoning the `CommonTermsQuery`. Default: `false`.\n     *\n     * **NOTE**: This has been removed in elasticsearch 6.0. If provided,\n     * it will be ignored and a deprecation warning will be issued.\n     *\n     * @param {boolean} enable\n     * @returns {BoolQuery} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'disableCoord',\n    value: function disableCoord(enable) {\n      this._queryOpts.disable_coord = enable;\n      return this;\n    }\n    /**\n     * Sets the value controlling how many `should` clauses in the boolean\n     * query should match. It can be an absolute value (2), a percentage (30%)\n     * or a combination of both. By default no optional clauses are necessary for a match.\n     * However, if the bool query is used in a filter context and it has `should` clauses then,\n     * at least one `should` clause is required to match.\n     *\n     * @param {string|number} minimumShouldMatch An absolute value (2), a percentage (30%)\n     * or a combination of both.\n     * @returns {BoolQuery} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'minimumShouldMatch',\n    value: function minimumShouldMatch(_minimumShouldMatch) {\n      this._queryOpts.minimum_should_match = _minimumShouldMatch;\n      return this;\n    }\n    /**\n     * Sets if the `Query` should be enhanced with a `MatchAllQuery` in order\n     * to act as a pure exclude when only negative (mustNot) clauses exist. Default: true.\n     *\n     * @param {boolean} enable\n     * @returns {BoolQuery} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'adjustPureNegative',\n    value: function adjustPureNegative(enable) {\n      this._queryOpts.adjust_pure_negative = enable;\n      return this;\n    }\n    /**\n     * Override default `toJSON` to return DSL representation of the `bool` compound query\n     * class instance.\n     *\n     * @override\n     * @returns {Object} returns an Object which maps to the elasticsearch query DSL\n     */\n\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      var _this3 = this;\n\n      var clauseKeys = ['must', 'filter', 'must_not', 'should']; // Pick the clauses which have some queries\n\n      var cleanQryOpts = clauseKeys.filter(function (clause) {\n        return has(_this3._queryOpts, clause);\n      }).reduce( // Unwrap array and put into qryOpts if required\n      function (qryOpts, clause) {\n        var clauseQueries = _this3._queryOpts[clause];\n        qryOpts[clause] = recursiveToJSON(clauseQueries.length === 1 ? head(clauseQueries) : clauseQueries);\n        return qryOpts;\n      }, // initial value - all key-value except clauses\n      omit(this._queryOpts, clauseKeys));\n      return (0, _defineProperty3.default)({}, this.queryType, cleanQryOpts);\n    }\n  }]);\n  return BoolQuery;\n}(Query);\n\nmodule.exports = BoolQuery;","map":null,"metadata":{},"sourceType":"script"}