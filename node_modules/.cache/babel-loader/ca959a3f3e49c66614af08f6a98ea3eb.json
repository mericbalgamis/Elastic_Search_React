{"ast":null,"code":"'use strict';\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = require('babel-runtime/helpers/inherits');\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar MultiTermQueryBase = require('./multi-term-query-base');\n\nvar _require = require('../helper'),\n    validateRewiteMethod = _require.validateRewiteMethod;\n\nvar ES_REF_URL = 'https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-prefix-query.html';\n/**\n * Matches documents that have fields containing terms with a specified prefix (**not analyzed**).\n *\n * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-prefix-query.html)\n *\n * @example\n * const qry = esb.prefixQuery('user', 'ki').boost(2.0);\n *\n * @param {string=} field\n * @param {string|number=} value\n *\n * @extends MultiTermQueryBase\n */\n\nvar PrefixQuery = function (_MultiTermQueryBase) {\n  (0, _inherits3.default)(PrefixQuery, _MultiTermQueryBase); // eslint-disable-next-line require-jsdoc\n\n  function PrefixQuery(field, value) {\n    (0, _classCallCheck3.default)(this, PrefixQuery);\n    return (0, _possibleConstructorReturn3.default)(this, (PrefixQuery.__proto__ || Object.getPrototypeOf(PrefixQuery)).call(this, 'prefix', field, value));\n  }\n  /**\n   * Sets the rewrite method. Valid values are:\n   * - `constant_score` - tries to pick the best constant-score rewrite\n   *  method based on term and document counts from the query.\n   *  Synonyms - `constant_score_auto`, `constant_score_filter`\n   *\n   * - `scoring_boolean` - translates each term into boolean should and\n   *  keeps the scores as computed by the query\n   *\n   * - `constant_score_boolean` - same as `scoring_boolean`, expect no scores\n   *  are computed.\n   *\n   * - `constant_score_filter` - first creates a private Filter, by visiting\n   *  each term in sequence and marking all docs for that term\n   *\n   * - `top_terms_boost_N` - first translates each term into boolean should\n   *  and scores are only computed as the boost using the top N\n   *  scoring terms. Replace N with an integer value.\n   *\n   * - `top_terms_N` - first translates each term into boolean should\n   *  and keeps the scores as computed by the query. Only the top N\n   *  scoring terms are used. Replace N with an integer value.\n   *\n   * Default is `constant_score`.\n   *\n   * This is an advanced option, use with care.\n   *\n   * Note: The deprecated multi term rewrite parameters `constant_score_auto`,\n   * `constant_score_filter` (synonyms for `constant_score`) have been removed\n   * in elasticsearch 6.0.\n   *\n   * @param {string} method The rewrite method as a string.\n   * @returns {PrefixQuery} returns `this` so that calls can be chained.\n   * @throws {Error} If the given `rewrite` method is not valid.\n   */\n\n\n  (0, _createClass3.default)(PrefixQuery, [{\n    key: 'rewrite',\n    value: function rewrite(method) {\n      validateRewiteMethod(method, 'rewrite', ES_REF_URL);\n      this._queryOpts.rewrite = method;\n      return this;\n    }\n  }]);\n  return PrefixQuery;\n}(MultiTermQueryBase);\n\nmodule.exports = PrefixQuery;","map":null,"metadata":{},"sourceType":"script"}