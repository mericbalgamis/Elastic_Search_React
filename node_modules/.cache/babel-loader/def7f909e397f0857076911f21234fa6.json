{"ast":null,"code":"'use strict';\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = require('babel-runtime/helpers/inherits');\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar isNil = require('lodash.isnil');\n\nvar _require = require('../../core'),\n    GeoShape = _require.GeoShape,\n    IndexedShape = _require.IndexedShape,\n    _require$util = _require.util,\n    checkType = _require$util.checkType,\n    invalidParam = _require$util.invalidParam,\n    GEO_RELATION_SET = _require.consts.GEO_RELATION_SET;\n\nvar GeoQueryBase = require('./geo-query-base');\n\nvar ES_REF_URL = 'https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-geo-shape-query.html';\nvar invalidRelationParam = invalidParam(ES_REF_URL, 'relation', GEO_RELATION_SET);\n/**\n * Filter documents indexed using the `geo_shape` type. Requires\n * the `geo_shape` Mapping.\n *\n * The `geo_shape` query uses the same grid square representation as\n * the `geo_shape` mapping to find documents that have a shape that\n * intersects with the query shape. It will also use the same PrefixTree\n * configuration as defined for the field mapping.\n *\n * The query supports two ways of defining the query shape, either by\n * providing a whole shape definition, or by referencing the name of\n * a shape pre-indexed in another index.\n *\n * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-geo-shape-query.html)\n *\n * @example\n * const geoQry = esb.geoShapeQuery('location')\n *     .shape(esb.geoShape()\n *         .type('envelope')\n *         .coordinates([[13.0, 53.0], [14.0, 52.0]]))\n *     .relation('within');\n *\n * @example\n * // Pre-indexed shape\n * const geoQry = esb.geoShapeQuery()\n *     .field('location')\n *     .indexedShape(esb.indexedShape()\n *         .id('DEU')\n *         .type('countries')\n *         .index('shapes')\n *         .path('location'))\n *\n * @param {string=} field\n *\n * @extends GeoQueryBase\n */\n\nvar GeoShapeQuery = function (_GeoQueryBase) {\n  (0, _inherits3.default)(GeoShapeQuery, _GeoQueryBase); // eslint-disable-next-line require-jsdoc\n\n  function GeoShapeQuery(field) {\n    (0, _classCallCheck3.default)(this, GeoShapeQuery);\n    return (0, _possibleConstructorReturn3.default)(this, (GeoShapeQuery.__proto__ || Object.getPrototypeOf(GeoShapeQuery)).call(this, 'geo_shape', field));\n  }\n  /**\n   * @override\n   * @throws {Error} This method cannot be called on GeoShapeQuery\n   */\n\n\n  (0, _createClass3.default)(GeoShapeQuery, [{\n    key: 'validationMethod',\n    value: function validationMethod() {\n      console.log('Please refer ' + ES_REF_URL);\n      throw new Error('validationMethod is not supported in GeoShapeQuery');\n    }\n    /**\n     * Sets the shape definition for the geo query.\n     *\n     * @param {GeoShape} shape\n     * @returns {GeoShapeQuery} returns `this` so that calls can be chained.\n     * @throws {TypeError} If given `shape` is not an instance of `GeoShape`\n     */\n\n  }, {\n    key: 'shape',\n    value: function shape(_shape) {\n      checkType(_shape, GeoShape);\n      this._fieldOpts.shape = _shape;\n      return this;\n    }\n    /**\n     * Sets the reference name of a shape pre-indexed in another index.\n     *\n     * @param {IndexedShape} shape\n     * @returns {GeoShapeQuery} returns `this` so that calls can be chained.\n     * @throws {TypeError} If given `shape` is not an instance of `IndexedShape`\n     */\n\n  }, {\n    key: 'indexedShape',\n    value: function indexedShape(shape) {\n      checkType(shape, IndexedShape);\n      this._fieldOpts.indexed_shape = shape;\n      return this;\n    }\n    /**\n     * Sets the relationship between Query and indexed data\n     * that will be used to determine if a Document should be matched or not.\n     *\n     * @param {string} relation Can be one of `WITHIN`, `CONTAINS`, `DISJOINT`\n     * or `INTERSECTS`(default)\n     * @returns {GeoShapeQuery} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'relation',\n    value: function relation(_relation) {\n      if (isNil(_relation)) invalidRelationParam(_relation);\n\n      var relationUpper = _relation.toUpperCase();\n\n      if (!GEO_RELATION_SET.has(relationUpper)) {\n        invalidRelationParam(_relation);\n      }\n\n      this._fieldOpts.relation = relationUpper;\n      return this;\n    }\n    /**\n     * When set to `true` will ignore an unmapped `path` and will not match any\n     * documents for this query. When set to `false` (the default value) the query\n     * will throw an exception if the path is not mapped.\n     *\n     * @param {boolean} enable `true` or `false`, `false` by default.\n     * @returns {GeoShapeQuery} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'ignoreUnmapped',\n    value: function ignoreUnmapped(enable) {\n      this._queryOpts.ignore_unmapped = enable;\n      return this;\n    }\n  }]);\n  return GeoShapeQuery;\n}(GeoQueryBase);\n\nmodule.exports = GeoShapeQuery;","map":null,"metadata":{},"sourceType":"script"}