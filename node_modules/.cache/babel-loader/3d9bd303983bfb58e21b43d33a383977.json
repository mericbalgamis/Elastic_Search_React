{"ast":null,"code":"'use strict';\n\nvar _defineProperty2 = require('babel-runtime/helpers/defineProperty');\n\nvar _defineProperty3 = _interopRequireDefault(_defineProperty2);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar isEmpty = require('lodash.isempty');\n\nvar has = require('lodash.has');\n\nvar isNil = require('lodash.isnil');\n\nvar Query = require('./query');\n\nvar Script = require('./script');\n\nvar _require = require('./util'),\n    checkType = _require.checkType,\n    invalidParam = _require.invalidParam,\n    recursiveToJSON = _require.recursiveToJSON;\n\nvar _require2 = require('./consts'),\n    SORT_MODE_SET = _require2.SORT_MODE_SET,\n    UNIT_SET = _require2.UNIT_SET;\n\nvar ES_REF_URL = 'https://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-sort.html';\nvar invalidOrderParam = invalidParam(ES_REF_URL, 'order', \"'asc' or 'desc'\");\nvar invalidModeParam = invalidParam(ES_REF_URL, 'mode', SORT_MODE_SET);\nvar invalidDistanceTypeParam = invalidParam(ES_REF_URL, 'distance_type', \"'plane' or 'arc'\");\nvar invalidUnitParam = invalidParam(ES_REF_URL, 'unit', UNIT_SET);\n/**\n * Allows creating and configuring sort on specified field.\n *\n * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-sort.html)\n *\n * @example\n * const reqBody = esb.requestBodySearch()\n *     .query(esb.termQuery('user', 'kimchy'))\n *     .sort(esb.sort('post_date', 'asc'))\n *\n * @param {string=} field The field to sort on.\n * If a script is used to specify the sort order, `field` should be omitted.\n * @param {string=} order The `order` option can have the following values.\n * `asc`, `desc` to sort in ascending, descending order respectively.\n */\n\nvar Sort = function () {\n  // eslint-disable-next-line require-jsdoc\n  function Sort(field, order) {\n    (0, _classCallCheck3.default)(this, Sort);\n    this._opts = {};\n    this._geoPoint = null;\n    this._script = null;\n    if (!isNil(field)) this._field = field;\n    if (!isNil(order)) this.order(order);\n  }\n  /**\n   * Set order for sorting. The order defaults to `desc` when sorting on the `_score`,\n   * and defaults to `asc` when sorting on anything else.\n   *\n   * @param {string} order The `order` option can have the following values.\n   * `asc`, `desc` to sort in ascending, descending order respectively.\n   * @returns {Sort} returns `this` so that calls can be chained.\n   */\n\n\n  (0, _createClass3.default)(Sort, [{\n    key: 'order',\n    value: function order(_order) {\n      if (isNil(_order)) invalidOrderParam(_order);\n\n      var orderLower = _order.toLowerCase();\n\n      if (orderLower !== 'asc' && orderLower !== 'desc') {\n        invalidOrderParam(_order);\n      }\n\n      this._opts.order = orderLower;\n      return this;\n    }\n    /**\n     * Elasticsearch supports sorting by array or multi-valued fields.\n     * The `mode` option controls what array value is picked for sorting the\n     * document it belongs to.\n     *\n     * The `mode` option can have the following values:\n     *\n     * - `min` - Pick the lowest value.\n     * - `max` - Pick the highest value.\n     * - `sum` - Use the sum of all values as sort value.\n     *   Only applicable for number based array fields.\n     * - `avg` - Use the average of all values as sort value.\n     *   Only applicable for number based array fields.\n     * - `median` - Use the median of all values as sort value.\n     *   Only applicable for number based array fields.\n     *\n     * @example\n     * const sort = esb.sort('price', 'asc').mode('avg');\n     *\n     * @param {string} mode One of `avg`, `min`, `max`, `sum` and `median`.\n     * @returns {Sort} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'mode',\n    value: function mode(_mode) {\n      if (isNil(_mode)) invalidModeParam(_mode);\n\n      var modeLower = _mode.toLowerCase();\n\n      if (!SORT_MODE_SET.has(modeLower)) {\n        invalidModeParam(_mode);\n      }\n\n      this._opts.mode = modeLower;\n      return this;\n    }\n    /**\n     * Defines on which nested object to sort. The actual sort field must be a direct\n     * field inside this nested object. When sorting by nested field, this field\n     * is mandatory.\n     *\n     * Note: This method has been deprecated in elasticsearch 6.1. From 6.1 and\n     * later, use `nested` method instead.\n     *\n     * @example\n     * const sort = esb.sort('offer.price', 'asc')\n     *     .nestedPath('offer')\n     *     .nestedFilter(esb.termQuery('offer.color', 'blue'));\n     *\n     * @param {string} path Nested object to sort on\n     * @returns {Sort} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'nestedPath',\n    value: function nestedPath(path) {\n      this._opts.nested_path = path;\n      return this;\n    }\n    /**\n     * A filter that the inner objects inside the nested path should match with in order\n     * for its field values to be taken into account by sorting. By default no\n     * `nested_filter` is active.\n     *\n     * Note: This method has been deprecated in elasticsearch 6.1. From 6.1 and\n     * later, use `nested` method instead.\n     *\n     * @example\n     * const sort = esb.sort('offer.price', 'asc')\n     *     .nestedPath('offer')\n     *     .nestedFilter(esb.termQuery('offer.color', 'blue'));\n     *\n     * @param {Query} filterQuery Filter query\n     * @returns {Sort} returns `this` so that calls can be chained.\n     * @throws {TypeError} If filter query is not an instance of `Query`\n     */\n\n  }, {\n    key: 'nestedFilter',\n    value: function nestedFilter(filterQuery) {\n      checkType(filterQuery, Query);\n      this._opts.nested_filter = filterQuery;\n      return this;\n    }\n    /**\n     * Defines on which nested object to sort and the filter that the inner objects inside\n     * the nested path should match with in order for its field values to be taken into\n     * account by sorting\n     *\n     * Note: This method is incompatible with elasticsearch 6.0 and older.\n     * Use it only with elasticsearch 6.1 and later.\n     *\n     * @example\n     * const sort = esb.sort('offer.price', 'asc')\n     *     .nested({\n     *          path: 'offer',\n     *          filter: esb.termQuery('offer.color', 'blue')\n     *      });\n     *\n     * @param {Object} nested Nested config that contains path and filter\n     * @param {string} nested.path Nested object to sort on\n     * @param {Query} nested.filter Filter query\n     * @returns {Sort} returns `this` so that calls can be chained.\n     * @throws {TypeError} If filter query is not an instance of `Query`\n     */\n\n  }, {\n    key: 'nested',\n    value: function nested(_nested) {\n      var filter = _nested.filter;\n      if (!isNil(filter)) checkType(filter, Query);\n      this._opts.nested = _nested;\n      return this;\n    }\n    /**\n     * The missing parameter specifies how docs which are missing the field should\n     * be treated: The missing value can be set to `_last`, `_first`, or a custom value\n     * (that will be used for missing docs as the sort value). The default is `_last`.\n     *\n     * @example\n     * const sort = esb.sort('price').missing('_last');\n     *\n     * @param {string|number} value\n     * @returns {Sort} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'missing',\n    value: function missing(value) {\n      this._opts.missing = value;\n      return this;\n    }\n    /**\n     * By default, the search request will fail if there is no mapping associated with\n     * a field. The `unmapped_type` option allows to ignore fields that have no mapping\n     * and not sort by them. The value of this parameter is used to determine what sort\n     * values to emit.\n     *\n     * @example\n     * const sort = esb.sort('price').unmappedType('long');\n     *\n     * @param {string} type\n     * @returns {Sort} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'unmappedType',\n    value: function unmappedType(type) {\n      this._opts.unmapped_type = type;\n      return this;\n    }\n    /**\n     * Sorts documents by distance of the geo point field from reference point.\n     * If multiple reference points are specified, the final distance for a\n     * document will then be `min`/`max`/`avg` (defined via `mode`) distance of all\n     * points contained in the document to all points given in the sort request.\n     *\n     * @example\n     * const sort = esb.sort('pin.location', 'asc')\n     *     .geoDistance([-70, 40])\n     *     .unit('km')\n     *     .mode('min')\n     *     .distanceType('arc');\n     *\n     * @param {GeoPoint|Object|Array|string} geoPoint Reference point or array of\n     * points to calculate distance from. Can be expressed using the `GeoPoint` class,\n     * `Object` with `lat`, `lon` keys, as a string either `lat,lon` or geohash\n     * or as Array with GeoJSON format `[lon, lat]`\n     * @returns {Sort} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'geoDistance',\n    value: function geoDistance(geoPoint) {\n      this._geoPoint = geoPoint;\n      return this;\n    }\n    /**\n     * Sets the distance calculation mode, `arc` or `plane`.\n     * The `arc` calculation is the more accurate.\n     * The `plane` is the faster but least accurate.\n     *\n     * @param {string} type\n     * @returns {Sort} returns `this` so that calls can be chained\n     * @throws {Error} If `type` is neither `plane` nor `arc`.\n     */\n\n  }, {\n    key: 'distanceType',\n    value: function distanceType(type) {\n      if (isNil(type)) invalidDistanceTypeParam(type);\n      var typeLower = type.toLowerCase();\n\n      if (typeLower !== 'plane' && typeLower !== 'arc') {\n        invalidDistanceTypeParam(type);\n      }\n\n      this._opts.distance_type = typeLower;\n      return this;\n    }\n    /**\n     * Sets the distance unit.  Valid values are:\n     * mi (miles), in (inches), yd (yards),\n     * km (kilometers), cm (centimeters), mm (millimeters),\n     * ft(feet), NM(nauticalmiles)\n     *\n     * @param {string} unit Distance unit, default is `m`(meters).\n     * @returns {Sort} returns `this` so that calls can be chained\n     * @throws {Error} If Unit is outside the accepted set.\n     */\n\n  }, {\n    key: 'unit',\n    value: function unit(_unit) {\n      if (!UNIT_SET.has(_unit)) {\n        invalidUnitParam(_unit);\n      }\n\n      this._opts.unit = _unit;\n      return this;\n    }\n    /**\n     * Sorts based on custom script. When sorting on a field, scores are not computed.\n     *\n     * @example\n     * const sort = esb.sort()\n     *    .type('number')\n     *    .script(\n     *        esb.script('inline', \"doc['field_name'].value * params.factor\")\n     *            .lang('painless')\n     *            .params({ factor: 1.1 })\n     *    )\n     *    .order('asc');\n     *\n     * @param {Script} script\n     * @returns {Sort} returns `this` so that calls can be chained\n     * @throws {TypeError} If `script` is not an instance of `Script`\n     */\n\n  }, {\n    key: 'script',\n    value: function script(_script) {\n      checkType(_script, Script);\n      this._script = _script;\n      return this;\n    }\n    /**\n     * Sets the data type for field generated by script.\n     *\n     * @param {string} type\n     * @returns {Sort} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'type',\n    value: function type(_type) {\n      this._opts.type = _type;\n      return this;\n    }\n    /**\n     * Reverse the sort order. Valid during sort types: field, geo distance, and script.\n     *\n     * @param {boolean} reverse If sort should be in reverse order.\n     * @returns {Sort} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'reverse',\n    value: function reverse(_reverse) {\n      this._opts.reverse = _reverse;\n      return this;\n    }\n    /**\n     * Override default `toJSON` to return DSL representation for `sort` parameter.\n     *\n     * @override\n     * @returns {Object|string} returns an Object which maps to the elasticsearch query DSL\n     */\n\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      var geoPointIsNil = isNil(this._geoPoint);\n      var scriptIsNil = isNil(this._script);\n\n      if (geoPointIsNil && scriptIsNil) {\n        if (isEmpty(this._opts)) return this._field;\n\n        if (Object.keys(this._opts).length === 1 && has(this._opts, 'order')) {\n          return (0, _defineProperty3.default)({}, this._field, this._opts.order);\n        }\n      }\n\n      var repr = void 0; // Should I pick only the accepted properties here?\n\n      if (!geoPointIsNil) {\n        repr = {\n          _geo_distance: Object.assign((0, _defineProperty3.default)({}, this._field, this._geoPoint), this._opts)\n        };\n      } else if (!scriptIsNil) {\n        repr = {\n          _script: Object.assign({\n            script: this._script\n          }, this._opts)\n        };\n      } else {\n        repr = (0, _defineProperty3.default)({}, this._field, this._opts);\n      }\n\n      return recursiveToJSON(repr);\n    }\n  }]);\n  return Sort;\n}();\n\nmodule.exports = Sort;","map":null,"metadata":{},"sourceType":"script"}