{"ast":null,"code":"'use strict';\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar isNil = require('lodash.isnil');\n\nvar _require = require('./util'),\n    recursiveToJSON = _require.recursiveToJSON;\n/**\n * Class supporting the Elasticsearch search template API.\n *\n * The `/_search/template` endpoint allows to use the mustache language to\n * pre render search requests, before they are executed and fill existing\n * templates with template parameters.\n *\n * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-template.html)\n *\n * @param {string=} type One of `inline`, `id`, `file`. `id` is also\n * aliased as `indexed`\n * @param {string|Object=} source Source of the search template.\n * This needs to be specified if optional argument `type` is passed.\n *\n * @example\n * const templ = esb.searchTemplate('inline', {\n *     query: esb.matchQuery('{{my_field}}', '{{my_value}}'),\n *     size: '{{my_size}}'\n * }).params({\n *     my_field: 'message',\n *     my_value: 'some message',\n *     my_size: 5\n * });\n *\n * @example\n * const templ = new esb.SearchTemplate(\n *     'inline',\n *     '{ \"query\": { \"terms\": {{#toJson}}statuses{{/toJson}} }}'\n * ).params({\n *     statuses: {\n *         status: ['pending', 'published']\n *     }\n * });\n *\n * @example\n * const templ = new esb.SearchTemplate(\n *     'inline',\n *     '{ \"query\": { \"bool\": { \"must\": {{#toJson}}clauses{{/toJson}} } } }'\n * ).params({\n *     clauses: [\n *         esb.termQuery('user', 'boo'),\n *         esb.termQuery('user', 'bar'),\n *         esb.termQuery('user', 'baz')\n *     ]\n * });\n */\n\n\nvar SearchTemplate = function () {\n  // eslint-disable-next-line require-jsdoc\n  function SearchTemplate(type, source) {\n    (0, _classCallCheck3.default)(this, SearchTemplate);\n    this._isTypeSet = false;\n    this._body = {};\n\n    if (!isNil(type) && !isNil(source)) {\n      var typeLower = type.toLowerCase();\n\n      if (typeLower !== 'inline' && typeLower !== 'id' && typeLower !== 'indexed' && // alias for id\n      typeLower !== 'file') {\n        throw new Error('`type` must be one of `inline`, `id`, `indexed`, `file`');\n      }\n\n      this[typeLower](source);\n    }\n  }\n  /**\n   * Print warning message to console namespaced by class name.\n   *\n   * @param {string} msg\n   * @private\n   */\n\n\n  (0, _createClass3.default)(SearchTemplate, [{\n    key: '_warn',\n    value: function _warn(msg) {\n      console.warn('[SearchTemplate] ' + msg);\n    }\n    /**\n     * Print warning messages to not mix `SearchTemplate` source\n     *\n     * @private\n     */\n\n  }, {\n    key: '_checkMixedRepr',\n    value: function _checkMixedRepr() {\n      if (this._isTypeSet) {\n        this._warn('Search template source(`inline`/`id`/`file`) was already specified!');\n\n        this._warn('Overwriting.');\n\n        delete this._body.file;\n        delete this._body.id;\n        delete this._body.file;\n      }\n    }\n    /**\n     * Helper method to set the type and source\n     *\n     * @param {string} type\n     * @param {*} source\n     * @returns {SearchTemplate} returns `this` so that calls can be chained.\n     * @private\n     */\n\n  }, {\n    key: '_setSource',\n    value: function _setSource(type, source) {\n      this._checkMixedRepr();\n\n      this._body[type] = source;\n      this._isTypeSet = true;\n      return this;\n    }\n    /**\n     * Sets the type of search template to be `inline` and specifies the\n     * template with `query` and other optional fields such as `size`.\n     *\n     * @param {string|Object} templ Either an object or a string.\n     * @returns {SearchTemplate} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'inline',\n    value: function inline(templ) {\n      return this._setSource('inline', templ);\n    }\n    /**\n     * Specify the indexed search template by `templateName` which will be\n     * retrieved from cluster state.\n     *\n     * @param {string} templId The unique identifier for the indexed template.\n     * @returns {SearchTemplate} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'id',\n    value: function id(templId) {\n      return this._setSource('id', templId);\n    }\n    /**\n     * Specify the indexed search template by `templateName` which will be\n     * retrieved from cluster state.\n     *\n     * Alias for `SearchTemplate.id`\n     *\n     * @param {string} templId The unique identifier for the indexed template.\n     * @returns {SearchTemplate} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'indexed',\n    value: function indexed(templId) {\n      return this.id(templId);\n    }\n    /**\n     * Specify the search template by filename stored in the scripts folder,\n     * with `mustache` extension.\n     *\n     * @example\n     * // `templId` - Name of the query template in config/scripts/, i.e.,\n     * // storedTemplate.mustache.\n     * const templ = new esb.SearchTemplate('file', 'storedTemplate').params({\n     *     query_string: 'search for these words'\n     * });\n     *\n     * @param {string} fileName The name of the search template stored as a file\n     * in the scripts folder.\n     * For file `config/scripts/storedTemplate.mustache`,\n     * `fileName` should be `storedTemplate`\n     * @returns {SearchTemplate} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'file',\n    value: function file(fileName) {\n      return this._setSource('file', fileName);\n    }\n    /**\n     * Specifies any named parameters that are used to render the search template.\n     *\n     * @param {Object} params Named parameters to be used for rendering.\n     * @returns {SearchTemplate} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'params',\n    value: function params(_params) {\n      this._body.params = _params;\n      return this;\n    }\n    /**\n     * Override default `toJSON` to return DSL representation for the Search Template.\n     *\n     * @override\n     * @returns {Object} returns an Object which maps to the elasticsearch query DSL\n     */\n\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return recursiveToJSON(this._body);\n    }\n  }]);\n  return SearchTemplate;\n}();\n\nmodule.exports = SearchTemplate;","map":null,"metadata":{},"sourceType":"script"}