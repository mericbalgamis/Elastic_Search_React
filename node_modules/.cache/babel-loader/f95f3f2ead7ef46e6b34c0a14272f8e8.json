{"ast":null,"code":"'use strict';\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = require('babel-runtime/helpers/inherits');\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar has = require('lodash.has');\n\nvar _require = require('../../core'),\n    Query = _require.Query,\n    checkType = _require.util.checkType;\n/**\n * The More Like This Query (MLT Query) finds documents that are \"like\" a given set\n * of documents. In order to do so, MLT selects a set of representative terms of\n * these input documents, forms a query using these terms, executes the query and\n * returns the results. The user controls the input documents, how the terms should\n * be selected and how the query is formed.\n *\n * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-mlt-query.html)\n *\n * @example\n * // Ask for documents that are similar to a provided piece of text\n * const qry = esb.moreLikeThisQuery()\n *     .fields(['title', 'description'])\n *     .like('Once upon a time')\n *     .minTermFreq(1)\n *     .maxQueryTerms(12);\n *\n * @example\n * // Mixing texts with documents already existing in the index\n * const qry = esb.moreLikeThisQuery()\n *     .fields(['title', 'description'])\n *     .like({ _index: 'imdb', _type: 'movies', _id: '1' })\n *     .like({ _index: 'imdb', _type: 'movies', _id: '2' })\n *     .like('and potentially some more text here as well')\n *     .minTermFreq(1)\n *     .maxQueryTerms(12);\n *\n * @example\n * // Provide documents not present in the index\n * const qry = esb.moreLikeThisQuery()\n *     .fields(['name.first', 'name.last'])\n *     .like([\n *         {\n *             _index: 'marvel',\n *             _type: 'quotes',\n *             doc: {\n *                 name: { first: 'Ben', last: 'Grimm' },\n *                 tweet: \"You got no idea what I'd... what I'd give to be invisible.\"\n *             }\n *         },\n *         { _index: 'marvel', _type: 'quotes', _id: '2' }\n *     ])\n *     .minTermFreq(1)\n *     .maxQueryTerms(12);\n *\n * @extends Query\n */\n\n\nvar MoreLikeThisQuery = function (_Query) {\n  (0, _inherits3.default)(MoreLikeThisQuery, _Query); // eslint-disable-next-line require-jsdoc\n\n  function MoreLikeThisQuery() {\n    (0, _classCallCheck3.default)(this, MoreLikeThisQuery);\n    return (0, _possibleConstructorReturn3.default)(this, (MoreLikeThisQuery.__proto__ || Object.getPrototypeOf(MoreLikeThisQuery)).call(this, 'more_like_this'));\n  }\n  /**\n   *\n   * @private\n   * @param {string} clauseType\n   * @param {string|Object|Array} clauses\n   */\n\n\n  (0, _createClass3.default)(MoreLikeThisQuery, [{\n    key: '_setSearchClause',\n    value: function _setSearchClause(clauseType, clauses) {\n      // Replace the field. Don't care about previous contents\n      if (Array.isArray(clauses)) this._queryOpts[clauseType] = clauses;else if (!has(this._queryOpts, clauseType)) {\n        // Keep the single `like` without array.\n        this._queryOpts[clauseType] = clauses;\n      } else {\n        // Wrap the single `like` in an array\n        if (!Array.isArray(this._queryOpts[clauseType])) {\n          this._queryOpts[clauseType] = [this._queryOpts[clauseType]];\n        } // Append to array\n\n\n        this._queryOpts[clauseType].push(clauses);\n      }\n    }\n    /**\n     * Sets the list of fields to fetch and analyze the text from. Defaults to\n     * the `_all` field for free text and to all possible fields for document inputs.\n     *\n     * @param {Array<string>} fields Array of fields to search against\n     * @returns {MoreLikeThisQuery} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'fields',\n    value: function fields(_fields) {\n      checkType(_fields, Array);\n      this._queryOpts.fields = _fields;\n      return this;\n    }\n    /**\n     * Sets the search clause for the query. It is the only required parameter of the MLT query\n     * and follows a versatile syntax, in which the user can specify free form text and/or\n     * a single or multiple documents (see examples above). The syntax to specify documents\n     * is similar to the one used by the [Multi GET API](https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-multi-get.html).\n     * When specifying documents, the text is fetched from fields unless overridden\n     * in each document request. The text is analyzed by the analyzer at the field,\n     * but could also be overridden. The syntax to override the analyzer at the\n     * field follows a similar syntax to the `per_field_analyzer` parameter of the\n     * [Term Vectors API](https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-termvectors.html#docs-termvectors-per-field-analyzer).\n     * Additionally, to provide documents not necessarily present in the index,\n     * [artificial documents](https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-termvectors.html#docs-termvectors-artificial-doc)\n     * are also supported.\n     *\n     * If string or object is passed, it is\n     * appended to the list. If an array is passed, it replaces the existing list.\n     *\n     * @param {string|Object|Array} like Can be passed as a string,\n     * Object representing indexed document, or array of string/objects.\n     * @returns {MoreLikeThisQuery} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'like',\n    value: function like(_like) {\n      this._setSearchClause('like', _like);\n\n      return this;\n    }\n    /**\n     * The `unlike` parameter is used in conjunction with `like` in order not to\n     * select terms found in a chosen set of documents. In other words, we could ask\n     * for documents `like`: \"Apple\", but `unlike`: \"cake crumble tree\".\n     * The syntax is the same as like.\n     *\n     * @param {string|Object|Array} unlike Can be passed as a string,\n     * Object representing indexed document, or array of string/objects.\n     * @returns {MoreLikeThisQuery} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'unlike',\n    value: function unlike(_unlike) {\n      this._setSearchClause('unlike', _unlike);\n\n      return this;\n    }\n    /**\n     * Sets the text to find documents like it.\n     *\n     * Note: This parameter has been removed in elasticsearch 6.0. Use `like`\n     * instead.\n     *\n     * @param {string} txt The text to find documents like it.\n     * @returns {MoreLikeThisQuery} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'likeText',\n    value: function likeText(txt) {\n      this._queryOpts.like_text = txt;\n      return this;\n    }\n    /**\n     * Sets the list of `ids` for the documents with syntax similar to\n     * the [Multi GET API](https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-multi-get.html).\n     *\n     * Note: This parameter has been removed in elasticsearch 6.0. Use `like`\n     * instead.\n     *\n     * @param {Array<string>} ids\n     * @returns {MoreLikeThisQuery} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'ids',\n    value: function ids(_ids) {\n      checkType(_ids, Array);\n      this._queryOpts.ids = _ids;\n      return this;\n    }\n    /**\n     * Sets the list of `docs` for the documents with syntax similar to\n     * the [Multi GET API](https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-multi-get.html).\n     *\n     * Note: This parameter has been removed in elasticsearch 6.0. Use `like`\n     * instead.\n     *\n     * @param {Array<Object>} docs\n     * @returns {MoreLikeThisQuery} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'docs',\n    value: function docs(_docs) {\n      checkType(_docs, Array);\n      this._queryOpts.docs = _docs;\n      return this;\n    }\n    /**\n     * Sets the maximum number of query terms that will be selected.\n     * Increasing this value gives greater accuracy at the expense of query execution speed.\n     * Defaults to `25`.\n     *\n     * @param {number} termsLimit The maximum number of query terms that will be selected.\n     * @returns {MoreLikeThisQuery} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'maxQueryTerms',\n    value: function maxQueryTerms(termsLimit) {\n      this._queryOpts.max_query_terms = termsLimit;\n      return this;\n    }\n    /**\n     * Sets the minimum term frequency below which the terms will be ignored from\n     * the input document Defaults to 2.\n     *\n     * @param {number} termFreqLimit\n     * @returns {MoreLikeThisQuery} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'minTermFreq',\n    value: function minTermFreq(termFreqLimit) {\n      this._queryOpts.min_term_freq = termFreqLimit;\n      return this;\n    }\n    /**\n     * Sets the minimum document frequency below which the terms will be ignored\n     * from the input document. Defaults to `5`.\n     *\n     * @param {number} docFreqLimit The minimum document frequency\n     * @returns {MoreLikeThisQuery} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'minDocFreq',\n    value: function minDocFreq(docFreqLimit) {\n      this._queryOpts.min_doc_freq = docFreqLimit;\n      return this;\n    }\n    /**\n     * Sets the maximum document frequency above which the terms will be ignored\n     * from the input document. Defaults to unbounded (`0`).\n     *\n     * @param {number} docFreqLimit The minimum document frequency\n     * @returns {MoreLikeThisQuery} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'maxDocFreq',\n    value: function maxDocFreq(docFreqLimit) {\n      this._queryOpts.max_doc_freq = docFreqLimit;\n      return this;\n    }\n    /**\n     * Sets the minimum word length below which the terms will be ignored.\n     * Defaults to `0`.\n     *\n     * @param {number} wordLenLimit\n     * @returns {MoreLikeThisQuery} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'minWordLength',\n    value: function minWordLength(wordLenLimit) {\n      this._queryOpts.min_word_length = wordLenLimit;\n      return this;\n    }\n    /**\n     * Sets the maximum word length above which the terms will be ignored.\n     * Defaults to unbounded (`0`).\n     *\n     * @param {number} wordLenLimit\n     * @returns {MoreLikeThisQuery} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'maxWordLength',\n    value: function maxWordLength(wordLenLimit) {\n      this._queryOpts.max_word_length = wordLenLimit;\n      return this;\n    }\n    /**\n     * Sets the array of stop words. Any word in this set is considered\n     * \"uninteresting\" and ignored.\n     *\n     * @param {Array<string>} words Array of stop words.\n     * @returns {MoreLikeThisQuery} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'stopWords',\n    value: function stopWords(words) {\n      this._queryOpts.stop_words = words;\n      return this;\n    }\n    /**\n     * Set the analyzer to control which analyzer will perform the analysis process on the text.\n     * Defaults to the analyzer associated with the first field in `fields`.\n     *\n     * @param {string} analyzer A valid text analyzer.\n     * @returns {MoreLikeThisQuery} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'analyzer',\n    value: function analyzer(_analyzer) {\n      this._queryOpts.analyzer = _analyzer;\n      return this;\n    }\n    /**\n     * Sets the value controlling how many `should` clauses in the boolean\n     * query should match. It can be an absolute value (2), a percentage (30%)\n     * or a combination of both. (Defaults to `\"30%\"`).\n     *\n     * @param {string|number} minimumShouldMatch An absolute value (`2`), a percentage (`30%`)\n     * or a combination of both.\n     * @returns {MoreLikeThisQuery} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'minimumShouldMatch',\n    value: function minimumShouldMatch(_minimumShouldMatch) {\n      this._queryOpts.minimum_should_match = _minimumShouldMatch;\n      return this;\n    }\n    /**\n     * Sets the boost factor to use when boosting terms.\n     * Defaults to deactivated (`0`).\n     *\n     * @param {number} boost A positive value to boost terms.\n     * @returns {MoreLikeThisQuery} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'boostTerms',\n    value: function boostTerms(boost) {\n      this._queryOpts.boost_terms = boost;\n      return this;\n    }\n    /**\n     * Specifies whether the input documents should also be included in the\n     * search results returned. Defaults to `false`.\n     *\n     * @param {boolean} enable\n     * @returns {MoreLikeThisQuery} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'include',\n    value: function include(enable) {\n      this._queryOpts.include = enable;\n      return this;\n    }\n  }]);\n  return MoreLikeThisQuery;\n}(Query);\n\nmodule.exports = MoreLikeThisQuery;","map":null,"metadata":{},"sourceType":"script"}