{"ast":null,"code":"'use strict';\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = require('babel-runtime/helpers/inherits');\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar isNil = require('lodash.isnil');\n\nvar _require = require('../../core'),\n    Aggregation = _require.Aggregation,\n    invalidParam = _require.util.invalidParam;\n\nvar invalidGapPolicyParam = invalidParam('', 'gap_policy', \"'skip' or 'insert_zeros'\");\n/**\n * The `PipelineAggregationBase` provides support for common options used across\n * various pipeline `Aggregation` implementations.\n *\n * Pipeline aggregations cannot have sub-aggregations but depending on the type\n * it can reference another pipeline in the buckets_path allowing pipeline\n * aggregations to be chained. For example, you can chain together two derivatives\n * to calculate the second derivative (i.e. a derivative of a derivative).\n *\n * **NOTE:** Instantiating this directly should not be required.\n * However, if you wish to add a custom implementation for whatever reason,\n * this class could be extended.\n *\n * @param {string} name a valid aggregation name\n * @param {string} aggType type of aggregation\n * @param {string} refUrl Elasticsearch reference URL\n * @param {string|Object=} bucketsPath The relative path of metric to aggregate over\n *\n * @extends Aggregation\n */\n\nvar PipelineAggregationBase = function (_Aggregation) {\n  (0, _inherits3.default)(PipelineAggregationBase, _Aggregation); // eslint-disable-next-line require-jsdoc\n\n  function PipelineAggregationBase(name, aggType, refUrl, bucketsPath) {\n    (0, _classCallCheck3.default)(this, PipelineAggregationBase);\n\n    var _this = (0, _possibleConstructorReturn3.default)(this, (PipelineAggregationBase.__proto__ || Object.getPrototypeOf(PipelineAggregationBase)).call(this, name, aggType));\n\n    _this._refUrl = refUrl;\n    if (!isNil(bucketsPath)) _this._aggsDef.buckets_path = bucketsPath;\n    return _this;\n  }\n  /**\n   * Sets the relative path, `buckets_path`, which refers to the metric to aggregate over.\n   * Required.\n   *\n   * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-pipeline.html#buckets-path-syntax)\n   *\n   * @example\n   * const reqBody = esb.requestBodySearch()\n   *     .agg(\n   *         esb.dateHistogramAggregation('histo', 'date')\n   *             .interval('day')\n   *             .agg(esb.termsAggregation('categories', 'category'))\n   *             .agg(\n   *                 esb.bucketSelectorAggregation('min_bucket_selector')\n   *                     .bucketsPath({ count: 'categories._bucket_count' })\n   *                     .script(esb.script('inline', 'params.count != 0'))\n   *             )\n   *     )\n   *     .size(0);\n   *\n   * @param {string|Object} path\n   * @returns {PipelineAggregationBase} returns `this` so that calls can be chained\n   */\n\n\n  (0, _createClass3.default)(PipelineAggregationBase, [{\n    key: 'bucketsPath',\n    value: function bucketsPath(path) {\n      this._aggsDef.buckets_path = path;\n      return this;\n    }\n    /**\n     * Set policy for missing data. Optional.\n     *\n     * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-pipeline.html#gap-policy)\n     *\n     * @param {string} policy Can be `skip` or `insert_zeros`\n     * @returns {PipelineAggregationBase} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'gapPolicy',\n    value: function gapPolicy(policy) {\n      if (isNil(policy)) invalidGapPolicyParam(policy, this._refUrl);\n      var policyLower = policy.toLowerCase();\n\n      if (policyLower !== 'skip' && policyLower !== 'insert_zeros') {\n        invalidGapPolicyParam(policy, this._refUrl);\n      }\n\n      this._aggsDef.gap_policy = policyLower;\n      return this;\n    }\n    /**\n     * Sets the format expression if applicable. Optional.\n     *\n     * @param {string} fmt Format mask to apply on aggregation response. Example: ####.00\n     * @returns {PipelineAggregationBase} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'format',\n    value: function format(fmt) {\n      this._aggsDef.format = fmt;\n      return this;\n    }\n  }]);\n  return PipelineAggregationBase;\n}(Aggregation);\n\nmodule.exports = PipelineAggregationBase;","map":null,"metadata":{},"sourceType":"script"}