{"ast":null,"code":"'use strict';\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = require('babel-runtime/helpers/inherits');\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar MultiTermQueryBase = require('./multi-term-query-base');\n\nvar _require = require('../helper'),\n    validateRewiteMethod = _require.validateRewiteMethod;\n\nvar ES_REF_URL = 'https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-regexp-query.html';\n/**\n * Query for regular expression term queries. Elasticsearch will apply the regexp\n * to the terms produced by the tokenizer for that field, and not to the original\n * text of the field.\n *\n * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-regexp-query.html)\n *\n * @example\n * const qry = esb.regexpQuery('name.first', 's.*y').boost(1.2);\n *\n * @param {string=} field\n * @param {string|number=} value\n *\n * @extends MultiTermQueryBase\n */\n\nvar RegexpQuery = function (_MultiTermQueryBase) {\n  (0, _inherits3.default)(RegexpQuery, _MultiTermQueryBase); // eslint-disable-next-line require-jsdoc\n\n  function RegexpQuery(field, value) {\n    (0, _classCallCheck3.default)(this, RegexpQuery);\n    return (0, _possibleConstructorReturn3.default)(this, (RegexpQuery.__proto__ || Object.getPrototypeOf(RegexpQuery)).call(this, 'regexp', field, value));\n  }\n  /**\n   * Set special flags. Possible flags are `ALL` (default),\n   * `ANYSTRING`, `COMPLEMENT`, `EMPTY`, `INTERSECTION`, `INTERVAL`, or `NONE`.\n   *\n   * @example\n   * const qry = esb.regexpQuery('name.first', 's.*y')\n   *     .flags('INTERSECTION|COMPLEMENT|EMPTY');\n   *\n   * @param {string} flags `|` separated flags. Possible flags are `ALL` (default),\n   * `ANYSTRING`, `COMPLEMENT`, `EMPTY`, `INTERSECTION`, `INTERVAL`, or `NONE`.\n   * @returns {RegexpQuery} returns `this` so that calls can be chained.\n   */\n\n\n  (0, _createClass3.default)(RegexpQuery, [{\n    key: 'flags',\n    value: function flags(_flags) {\n      this._queryOpts.flags = _flags;\n      return this;\n    }\n    /**\n     * Limit on how many automaton states regexp queries are allowed to create.\n     * This protects against too-difficult (e.g. exponentially hard) regexps.\n     * Defaults to 10000.\n     *\n     * @example\n     * const qry = esb.regexpQuery('name.first', 's.*y')\n     *     .flags('INTERSECTION|COMPLEMENT|EMPTY')\n     *     .maxDeterminizedStates(20000);\n     *\n     * @param {number} limit\n     * @returns {RegexpQuery} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'maxDeterminizedStates',\n    value: function maxDeterminizedStates(limit) {\n      this._queryOpts.max_determinized_states = limit;\n      return this;\n    }\n    /**\n     * Sets the rewrite method. Valid values are:\n     * - `constant_score` - tries to pick the best constant-score rewrite\n     *  method based on term and document counts from the query.\n     *  Synonyms - `constant_score_auto`, `constant_score_filter`\n     *\n     * - `scoring_boolean` - translates each term into boolean should and\n     *  keeps the scores as computed by the query\n     *\n     * - `constant_score_boolean` - same as `scoring_boolean`, expect no scores\n     *  are computed.\n     *\n     * - `constant_score_filter` - first creates a private Filter, by visiting\n     *  each term in sequence and marking all docs for that term\n     *\n     * - `top_terms_boost_N` - first translates each term into boolean should\n     *  and scores are only computed as the boost using the top N\n     *  scoring terms. Replace N with an integer value.\n     *\n     * - `top_terms_N` - first translates each term into boolean should\n     *  and keeps the scores as computed by the query. Only the top N\n     *  scoring terms are used. Replace N with an integer value.\n     *\n     * Default is `constant_score`.\n     *\n     * This is an advanced option, use with care.\n     *\n     * Note: The deprecated multi term rewrite parameters `constant_score_auto`,\n     * `constant_score_filter` (synonyms for `constant_score`) have been removed\n     * in elasticsearch 6.0.\n     *\n     * @param {string} method The rewrite method as a string.\n     * @returns {RegexpQuery} returns `this` so that calls can be chained.\n     * @throws {Error} If the given `rewrite` method is not valid.\n     */\n\n  }, {\n    key: 'rewrite',\n    value: function rewrite(method) {\n      validateRewiteMethod(method, 'rewrite', ES_REF_URL);\n      this._queryOpts.rewrite = method;\n      return this;\n    }\n  }]);\n  return RegexpQuery;\n}(MultiTermQueryBase);\n\nmodule.exports = RegexpQuery;","map":null,"metadata":{},"sourceType":"script"}