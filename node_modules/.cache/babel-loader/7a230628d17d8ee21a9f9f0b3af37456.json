{"ast":null,"code":"'use strict';\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar has = require('lodash.has'),\n    isEmpty = require('lodash.isempty'),\n    isNil = require('lodash.isnil'),\n    isString = require('lodash.isstring');\n\nvar Query = require('./query');\n\nvar _require = require('./util'),\n    checkType = _require.checkType,\n    invalidParam = _require.invalidParam,\n    recursiveToJSON = _require.recursiveToJSON;\n\nvar ES_REF_URL = 'https://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-highlighting.html';\nvar invalidEncoderParam = invalidParam(ES_REF_URL, 'encoder', \"'default' or 'html'\");\nvar invalidTypeParam = invalidParam(ES_REF_URL, 'type', \"'plain', 'postings' or 'fvh'\");\nvar invalidFragmenterParam = invalidParam(ES_REF_URL, 'fragmenter', \"'simple' or 'span'\");\n/**\n * Allows to highlight search results on one or more fields. In order to\n * perform highlighting, the actual content of the field is required. If the\n * field in question is stored (has store set to yes in the mapping), it will\n * be used, otherwise, the actual _source will be loaded and the relevant\n * field will be extracted from it.\n *\n * If no term_vector information is provided (by setting it to\n * `with_positions_offsets` in the mapping), then the plain highlighter will be\n * used. If it is provided, then the fast vector highlighter will be used.\n * When term vectors are available, highlighting will be performed faster at\n * the cost of bigger index size.\n *\n * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-highlighting.html)\n *\n * @example\n * const reqBody = esb.requestBodySearch()\n *     .query(esb.matchAllQuery())\n *     .highlight(esb.highlight('content'));\n *\n * @example\n * const highlight = esb.highlight()\n *     .numberOfFragments(3)\n *     .fragmentSize(150)\n *     .fields(['_all', 'bio.title', 'bio.author', 'bio.content'])\n *     .preTags('<em>', '_all')\n *     .postTags('</em>', '_all')\n *     .numberOfFragments(0, 'bio.title')\n *     .numberOfFragments(0, 'bio.author')\n *     .numberOfFragments(5, 'bio.content')\n *     .scoreOrder('bio.content');\n *\n * highlight.toJSON()\n * {\n *     \"number_of_fragments\" : 3,\n *     \"fragment_size\" : 150,\n *     \"fields\" : {\n *         \"_all\" : { \"pre_tags\" : [\"<em>\"], \"post_tags\" : [\"</em>\"] },\n *         \"bio.title\" : { \"number_of_fragments\" : 0 },\n *         \"bio.author\" : { \"number_of_fragments\" : 0 },\n *         \"bio.content\" : { \"number_of_fragments\" : 5, \"order\" : \"score\" }\n *     }\n *  }\n *\n * @param {string|Array=} fields An optional field or array of fields to highlight.\n */\n\nvar Highlight = function () {\n  // eslint-disable-next-line require-jsdoc\n  function Highlight(fields) {\n    (0, _classCallCheck3.default)(this, Highlight);\n    this._fields = {};\n    this._highlight = {\n      fields: this._fields\n    }; // Does this smell?\n\n    if (isNil(fields)) return;\n    if (isString(fields)) this.field(fields);else this.fields(fields);\n  }\n  /**\n   * Private function to set field option\n   *\n   * @param {string|null} field\n   * @param {string} option\n   * @param {string} val\n   * @private\n   */\n\n\n  (0, _createClass3.default)(Highlight, [{\n    key: '_setFieldOption',\n    value: function _setFieldOption(field, option, val) {\n      if (isNil(field)) {\n        this._highlight[option] = val;\n        return;\n      }\n\n      this.field(field);\n      this._fields[field][option] = val;\n    }\n    /**\n     * Allows you to set a field that will be highlighted. The field is\n     * added to the current list of fields.\n     *\n     * @param {string} field A field name.\n     * @returns {Highlight} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'field',\n    value: function field(_field) {\n      if (!isNil(_field) && !has(this._fields, _field)) {\n        this._fields[_field] = {};\n      }\n\n      return this;\n    }\n    /**\n     * Allows you to set the fields that will be highlighted. All fields are\n     * added to the current list of fields.\n     *\n     * @param {Array<string>} fields Array of field names.\n     * @returns {Highlight} returns `this` so that calls can be chained\n     * @throws {TypeError} If `fields` is not an instance of Array\n     */\n\n  }, {\n    key: 'fields',\n    value: function fields(_fields) {\n      var _this = this;\n\n      checkType(_fields, Array);\n\n      _fields.forEach(function (field) {\n        return _this.field(field);\n      });\n\n      return this;\n    }\n    /**\n     * Sets the pre tags for highlighted fragments. You can apply the\n     * tags to a specific field by passing the optional field name parameter.\n     *\n     * @example\n     * const highlight = esb.highlight('_all')\n     *     .preTags('<tag1>')\n     *     .postTags('</tag1>');\n     *\n     * @example\n     * const highlight = esb.highlight('_all')\n     *     .preTags(['<tag1>', '<tag2>'])\n     *     .postTags(['</tag1>', '</tag2>']);\n     *\n     * @param {string|Array} tags\n     * @param {string=} field\n     * @returns {Highlight} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'preTags',\n    value: function preTags(tags, field) {\n      this._setFieldOption(field, 'pre_tags', isString(tags) ? [tags] : tags);\n\n      return this;\n    }\n    /**\n     * Sets the post tags for highlighted fragments. You can apply the\n     * tags to a specific field by passing the optional field name parameter.\n     *\n     * @example\n     * const highlight = esb.highlight('_all')\n     *     .preTags('<tag1>')\n     *     .postTags('</tag1>');\n     *\n     * @example\n     * const highlight = esb.highlight('_all')\n     *     .preTags(['<tag1>', '<tag2>'])\n     *     .postTags(['</tag1>', '</tag2>']);\n     *\n     * @param {string|Array} tags\n     * @param {string=} field\n     * @returns {Highlight} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'postTags',\n    value: function postTags(tags, field) {\n      this._setFieldOption(field, 'post_tags', isString(tags) ? [tags] : tags);\n\n      return this;\n    }\n    /**\n     * Sets the styled schema to be used for the tags.\n     *\n     * styled - 10 `<em>` pre tags with css class of hltN, where N is 1-10\n     *\n     * @example\n     * const highlight = esb.highlight('content').styledTagsSchema();\n     *\n     * @returns {Highlight} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'styledTagsSchema',\n    value: function styledTagsSchema() {\n      // This is a special case as it does not map directly to elasticsearch DSL\n      // This is written this way for ease of use\n      this._highlight.tags_schema = 'styled';\n      return this;\n    }\n    /**\n     * Sets the order of highlight fragments to be sorted by score. You can apply the\n     * score order to a specific field by passing the optional field name parameter.\n     *\n     * @example\n     * const highlight = esb.highlight('content').scoreOrder()\n     *\n     * @param {string=} field An optional field name\n     * @returns {Highlight} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'scoreOrder',\n    value: function scoreOrder(field) {\n      // This is a special case as it does not map directly to elasticsearch DSL\n      // It is written this way for ease of use\n      this._setFieldOption(field, 'order', 'score');\n\n      return this;\n    }\n    /**\n     * Sets the size of each highlight fragment in characters. You can apply the\n     * option to a specific field by passing the optional field name parameter.\n     *\n     * @example\n     * const highlight = esb.highlight('content')\n     *     .fragmentSize(150, 'content')\n     *     .numberOfFragments(3, 'content');\n     *\n     * @param {number} size The fragment size in characters. Defaults to 100.\n     * @param {string=} field An optional field name\n     * @returns {Highlight} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'fragmentSize',\n    value: function fragmentSize(size, field) {\n      this._setFieldOption(field, 'fragment_size', size);\n\n      return this;\n    }\n    /**\n     * Sets the maximum number of fragments to return. You can apply the\n     * option to a specific field by passing the optional field name parameter.\n     *\n     * @example\n     * const highlight = esb.highlight('content')\n     *     .fragmentSize(150, 'content')\n     *     .numberOfFragments(3, 'content');\n     *\n     * @example\n     * const highlight = esb.highlight(['_all', 'bio.title'])\n     *     .numberOfFragments(0, 'bio.title');\n     *\n     * @param {number} count The maximum number of fragments to return\n     * @param {string=} field An optional field name\n     * @returns {Highlight} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'numberOfFragments',\n    value: function numberOfFragments(count, field) {\n      this._setFieldOption(field, 'number_of_fragments', count);\n\n      return this;\n    }\n    /**\n     * If `no_match_size` is set, in the case where there is no matching fragment\n     * to highlight, a snippet of text, with the specified length, from the beginning\n     * of the field will be returned.\n     *\n     * The actual length may be shorter than specified as it tries to break on a word boundary.\n     *\n     * Default is `0`.\n     *\n     * @example\n     * const highlight = esb.highlight('content')\n     *     .fragmentSize(150, 'content')\n     *     .numberOfFragments(3, 'content')\n     *     .noMatchSize(150, 'content');\n     *\n     * @param {number} size\n     * @param {string} field\n     * @returns {Highlight} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'noMatchSize',\n    value: function noMatchSize(size, field) {\n      this._setFieldOption(field, 'no_match_size', size);\n\n      return this;\n    }\n    /**\n     * Highlight against a query other than the search query.\n     * Useful if you use a rescore query because those\n     * are not taken into account by highlighting by default.\n     *\n     * @example\n     * const highlight = esb.highlight('content')\n     *     .fragmentSize(150, 'content')\n     *     .numberOfFragments(3, 'content')\n     *     .highlightQuery(\n     *         esb.boolQuery()\n     *             .must(esb.matchQuery('content', 'foo bar'))\n     *             .should(\n     *                 esb.matchPhraseQuery('content', 'foo bar').slop(1).boost(10)\n     *             )\n     *             .minimumShouldMatch(0),\n     *         'content'\n     *     );\n     *\n     * @param {Query} query\n     * @param {string=} field An optional field name\n     * @returns {Highlight} returns `this` so that calls can be chained\n     * @throws {TypeError} If `query` is not an instance of `Query`\n     */\n\n  }, {\n    key: 'highlightQuery',\n    value: function highlightQuery(query, field) {\n      checkType(query, Query);\n\n      this._setFieldOption(field, 'highlight_query', query);\n\n      return this;\n    }\n    /**\n     * Combine matches on multiple fields to highlight a single field.\n     * Useful for multifields that analyze the same string in different ways.\n     * Sets the highlight type to Fast Vector Highlighter(`fvh`).\n     *\n     * @example\n     * const highlight = esb.highlight('content')\n     *     .scoreOrder('content')\n     *     .matchedFields(['content', 'content.plain'], 'content');\n     *\n     * highlight.toJSON();\n     * {\n     *     \"order\": \"score\",\n     *     \"fields\": {\n     *         \"content\": {\n     *             \"matched_fields\": [\"content\", \"content.plain\"],\n     *             \"type\" : \"fvh\"\n     *         }\n     *     }\n     * }\n     *\n     * @param {Array<string>} fields\n     * @param {string} field Field name\n     * @returns {Highlight} returns `this` so that calls can be chained\n     * @throws {Error} field parameter should be valid field name\n     * @throws {TypeError} If `fields` is not an instance of Array\n     */\n\n  }, {\n    key: 'matchedFields',\n    value: function matchedFields(fields, field) {\n      checkType(fields, Array);\n\n      if (isEmpty(field)) {\n        throw new Error('`matched_fields` requires field name to be passed');\n      }\n\n      this.type('fvh', field);\n\n      this._setFieldOption(field, 'matched_fields', fields);\n\n      return this;\n    }\n    /**\n     * The fast vector highlighter has a phrase_limit parameter that prevents\n     * it from analyzing too many phrases and eating tons of memory. It defaults\n     * to 256 so only the first 256 matching phrases in the document scored\n     * considered. You can raise the limit with the phrase_limit parameter.\n     *\n     * If using `matched_fields`, `phrase_limit` phrases per matched field\n     * are considered.\n     *\n     * @param {number} limit Defaults to 256.\n     * @returns {Highlight} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'phraseLimit',\n    value: function phraseLimit(limit) {\n      this._highlight.phrase_limit = limit;\n      return this;\n    }\n    /**\n     * Can be used to define how highlighted text will be encoded.\n     *\n     * @param {string} encoder It can be either default (no encoding)\n     * or `html` (will escape `html`, if you use html highlighting tags)\n     * @returns {Highlight} returns `this` so that calls can be chained\n     * @throws {Error} Encoder can be either `default` or `html`\n     */\n\n  }, {\n    key: 'encoder',\n    value: function encoder(_encoder) {\n      if (isNil(_encoder)) invalidEncoderParam(_encoder);\n\n      var encoderLower = _encoder.toLowerCase();\n\n      if (encoderLower !== 'default' && encoderLower !== 'html') {\n        invalidEncoderParam(_encoder);\n      }\n\n      this._highlight.encoder = encoderLower;\n      return this;\n    }\n    /**\n     * By default only fields that hold a query match will be highlighted.\n     * This can be set to false to highlight the field regardless of whether\n     * the query matched specifically on them. You can apply the\n     * option to a specific field by passing the optional field name parameter.\n     *\n     * @example\n     * const highlight = esb.highlight('_all')\n     *     .preTags('<em>', '_all')\n     *     .postTags('</em>', '_all')\n     *     .requireFieldMatch(false);\n     *\n     * @param {boolean} requireFieldMatch\n     * @param {string=} field An optional field name\n     * @returns {Highlight} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'requireFieldMatch',\n    value: function requireFieldMatch(_requireFieldMatch, field) {\n      this._setFieldOption(field, 'require_field_match', _requireFieldMatch);\n\n      return this;\n    }\n    /**\n     * Allows to control how far to look for boundary characters, and defaults to 20.\n     * You can apply the option to a specific field by passing the optional field name parameter.\n     *\n     * @param {number} count The max characters to scan.\n     * @param {string=} field An optional field name\n     * @returns {Highlight} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'boundaryMaxScan',\n    value: function boundaryMaxScan(count, field) {\n      this._setFieldOption(field, 'boundary_max_scan', count);\n\n      return this;\n    }\n    /**\n     * Defines what constitutes a boundary for highlighting.\n     * It is a single string with each boundary character defined in it.\n     * It defaults to `.,!? \\t\\n`. You can apply the\n     * option to a specific field by passing the optional field name parameter.\n     *\n     * @param {string} charStr\n     * @param {string=} field An optional field name\n     * @returns {Highlight} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'boundaryChars',\n    value: function boundaryChars(charStr, field) {\n      this._setFieldOption(field, 'boundary_chars', charStr);\n\n      return this;\n    }\n    /**\n     * Allows to force a specific highlighter type.\n     * This is useful for instance when needing to use\n     * the plain highlighter on a field that has term_vectors enabled.\n     * You can apply the option to a specific field by passing the optional\n     * field name parameter.\n     *\n     * Note: The `postings` highlighter has been removed in elasticsearch 6.0.\n     * The `unified` highlighter outputs the same highlighting when\n     * `index_options` is set to `offsets`.\n     *\n     * @example\n     * const highlight = esb.highlight('content').type('plain', 'content');\n     *\n     * @param {string} type The allowed values are: `plain`, `postings` and `fvh`.\n     * @param {string=} field An optional field name\n     * @returns {Highlight} returns `this` so that calls can be chained\n     * @throws {Error} Type can be one of `plain`, `postings` or `fvh`.\n     */\n\n  }, {\n    key: 'type',\n    value: function type(_type, field) {\n      if (isNil(_type)) invalidTypeParam(_type);\n\n      var typeLower = _type.toLowerCase();\n\n      if (typeLower !== 'plain' && typeLower !== 'postings' && typeLower !== 'fvh') {\n        invalidTypeParam(_type);\n      }\n\n      this._setFieldOption(field, 'type', typeLower);\n\n      return this;\n    }\n    /**\n     * Forces the highlighting to highlight fields based on the source\n     * even if fields are stored separately. Defaults to false.\n     *\n     * @example\n     * const highlight = esb.highlight('content').forceSource(true, 'content');\n     *\n     * @param {boolean} forceSource\n     * @param {string=} field An optional field name\n     * @returns {Highlight} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'forceSource',\n    value: function forceSource(_forceSource, field) {\n      this._setFieldOption(field, 'force_source', _forceSource);\n\n      return this;\n    }\n    /**\n     * Sets the fragmenter type. You can apply the\n     * option to a specific field by passing the optional field name parameter.\n     * Valid values for order are:\n     *  - `simple` - breaks text up into same-size fragments with no concerns\n     *      over spotting sentence boundaries.\n     *  - `span` - breaks text up into same-size fragments but does not split\n     *      up Spans.\n     *\n     * @example\n     * const highlight = esb.highlight('message')\n     *     .fragmentSize(15, 'message')\n     *     .numberOfFragments(3, 'message')\n     *     .fragmenter('simple', 'message');\n     *\n     * @param {string} fragmenter The fragmenter.\n     * @param {string=} field An optional field name\n     * @returns {Highlight} returns `this` so that calls can be chained\n     * @throws {Error} Fragmenter can be either `simple` or `span`\n     */\n\n  }, {\n    key: 'fragmenter',\n    value: function fragmenter(_fragmenter, field) {\n      if (isNil(_fragmenter)) invalidFragmenterParam(_fragmenter);\n\n      var fragmenterLower = _fragmenter.toLowerCase();\n\n      if (fragmenterLower !== 'simple' && fragmenterLower !== 'span') {\n        invalidFragmenterParam(_fragmenter);\n      }\n\n      this._setFieldOption(field, 'fragmenter', fragmenterLower);\n\n      return this;\n    } // TODO: Support Explicit field order\n    // https://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-highlighting.html#explicit-field-order\n\n    /**\n     * Override default `toJSON` to return DSL representation for the `highlight` request\n     *\n     * @override\n     * @returns {Object} returns an Object which maps to the elasticsearch query DSL\n     */\n\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return recursiveToJSON(this._highlight);\n    }\n  }]);\n  return Highlight;\n}();\n\nmodule.exports = Highlight;","map":null,"metadata":{},"sourceType":"script"}