{"ast":null,"code":"'use strict';\n\nvar _defineProperty2 = require('babel-runtime/helpers/defineProperty');\n\nvar _defineProperty3 = _interopRequireDefault(_defineProperty2);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = require('babel-runtime/helpers/inherits');\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar has = require('lodash.has');\n\nvar isNil = require('lodash.isnil');\n\nvar _require = require('../../core'),\n    invalidParam = _require.util.invalidParam;\n\nvar TermsAggregationBase = require('./terms-aggregation-base');\n\nvar ES_REF_URL = 'https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-terms-aggregation.html';\nvar invalidDirectionParam = invalidParam(ES_REF_URL, 'direction', \"'asc' or 'desc'\");\nvar invalidCollectModeParam = invalidParam(ES_REF_URL, 'mode', \"'breadth_first' or 'depth_first'\");\n/**\n * A multi-bucket value source based aggregation where buckets are dynamically\n * built - one per unique value.\n *\n * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-terms-aggregation.html)\n *\n * @example\n * const agg = esb.termsAggregation('genres', 'genre');\n *\n * @param {string} name The name which will be used to refer to this aggregation.\n * @param {string=} field The field to aggregate on\n *\n * @extends TermsAggregationBase\n */\n\nvar TermsAggregation = function (_TermsAggregationBase) {\n  (0, _inherits3.default)(TermsAggregation, _TermsAggregationBase); // eslint-disable-next-line require-jsdoc\n\n  function TermsAggregation(name, field) {\n    (0, _classCallCheck3.default)(this, TermsAggregation);\n    return (0, _possibleConstructorReturn3.default)(this, (TermsAggregation.__proto__ || Object.getPrototypeOf(TermsAggregation)).call(this, name, 'terms', ES_REF_URL, field));\n  }\n  /**\n   * When set to `true`, shows an error value for each term returned by the aggregation\n   * which represents the _worst case error_ in the document count and can be useful\n   * when deciding on a value for the shard_size parameter.\n   *\n   * @param {booleam} enable\n   * @returns {TermsAggregation} returns `this` so that calls can be chained\n   */\n\n\n  (0, _createClass3.default)(TermsAggregation, [{\n    key: 'showTermDocCountError',\n    value: function showTermDocCountError(enable) {\n      this._aggsDef.show_term_doc_count_error = enable;\n      return this;\n    }\n    /**\n     * Break the analysis up into multiple requests by grouping the fieldâ€™s values\n     * into a number of partitions at query-time and processing only one\n     * partition in each request.\n     *\n     * Note that this method is a special case as the name doesn't map to the\n     * elasticsearch parameter name. This is required because there is already\n     * a method for `include` applicable for Terms aggregations. However, this\n     * could change depending on community interest.\n     *\n     * @example\n     * const agg = esb.termsAggregation('expired_sessions', 'account_id')\n     *     .includePartition(0, 20)\n     *     .size(10000)\n     *     .order('last_access', 'asc')\n     *     .agg(esb.maxAggregation('last_access', 'access_date'));\n     *\n     * @param {number} partition\n     * @param {number} numPartitions\n     * @returns {TermsAggregation} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'includePartition',\n    value: function includePartition(partition, numPartitions) {\n      // TODO: Print warning if include key is being overwritten\n      this._aggsDef.include = {\n        partition: partition,\n        num_partitions: numPartitions\n      };\n      return this;\n    }\n    /**\n     * Can be used for deferring calculation of child aggregations by using\n     * `breadth_first` mode. In `depth_first` mode all branches of the aggregation\n     * tree are expanded in one depth-first pass and only then any pruning occurs.\n     *\n     * @example\n     * const agg = esb.termsAggregation('actors', 'actors')\n     *     .size(10)\n     *     .collectMode('breadth_first')\n     *     .agg(esb.termsAggregation('costars', 'actors').size(5));\n     *\n     * @param {string} mode The possible values are `breadth_first` and `depth_first`.\n     * @returns {TermsAggregation} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'collectMode',\n    value: function collectMode(mode) {\n      if (isNil(mode)) invalidCollectModeParam(mode);\n      var modeLower = mode.toLowerCase();\n\n      if (modeLower !== 'breadth_first' && modeLower !== 'depth_first') {\n        invalidCollectModeParam(mode);\n      }\n\n      this._aggsDef.collect_mode = modeLower;\n      return this;\n    }\n    /**\n     * Sets the ordering for buckets\n     *\n     * @example\n     * // Ordering the buckets by their doc `_count` in an ascending manner\n     * const agg = esb.termsAggregation('genres', 'genre').order('_count', 'asc');\n     *\n     * @example\n     * // Ordering the buckets alphabetically by their terms in an ascending manner\n     * const agg = esb.termsAggregation('genres', 'genre').order('_term', 'asc');\n     *\n     * @example\n     * // Ordering the buckets by single value metrics sub-aggregation\n     * // (identified by the aggregation name)\n     * const agg = esb.termsAggregation('genres', 'genre')\n     *     .order('max_play_count', 'asc')\n     *     .agg(esb.maxAggregation('max_play_count', 'play_count'));\n     *\n     * @example\n     * // Ordering the buckets by multi value metrics sub-aggregation\n     * // (identified by the aggregation name):\n     * const agg = esb.termsAggregation('genres', 'genre')\n     *     .order('playback_stats.max', 'desc')\n     *     .agg(esb.statsAggregation('playback_stats', 'play_count'));\n     *\n     * @example\n     * // Multiple order criteria\n     * const agg = esb.termsAggregation('countries')\n     *     .field('artist.country')\n     *     .order('rock>playback_stats.avg', 'desc')\n     *     .order('_count', 'desc')\n     *     .agg(\n     *         esb.filterAggregation('rock')\n     *             .filter(esb.termQuery('genre', 'rock'))\n     *             .agg(esb.statsAggregation('playback_stats', 'play_count'))\n     *     );\n     *\n     * @param {string} key\n     * @param {string} direction `asc` or `desc`\n     * @returns {TermsAggregation} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'order',\n    value: function order(key) {\n      var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'desc';\n      if (isNil(direction)) invalidDirectionParam(direction);\n      var directionLower = direction.toLowerCase();\n\n      if (directionLower !== 'asc' && directionLower !== 'desc') {\n        invalidDirectionParam(direction);\n      }\n\n      if (has(this._aggsDef, 'order')) {\n        if (!Array.isArray(this._aggsDef.order)) {\n          this._aggsDef.order = [this._aggsDef.order];\n        }\n\n        this._aggsDef.order.push((0, _defineProperty3.default)({}, key, directionLower));\n      } else {\n        this._aggsDef.order = (0, _defineProperty3.default)({}, key, directionLower);\n      }\n\n      return this;\n    }\n  }]);\n  return TermsAggregation;\n}(TermsAggregationBase);\n\nmodule.exports = TermsAggregation;","map":null,"metadata":{},"sourceType":"script"}