{"ast":null,"code":"'use strict';\n\nvar _defineProperty2 = require('babel-runtime/helpers/defineProperty');\n\nvar _defineProperty3 = _interopRequireDefault(_defineProperty2);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = require('babel-runtime/helpers/inherits');\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar has = require('lodash.has');\n\nvar isNil = require('lodash.isnil');\n\nvar _require = require('../../core'),\n    invalidParam = _require.util.invalidParam;\n\nvar BucketAggregationBase = require('./bucket-aggregation-base');\n\nvar invalidDirectionParam = invalidParam('', 'direction', \"'asc' or 'desc'\");\n/**\n * The `HistogramAggregationBase` provides support for common options used across\n * various histogram `Aggregation` implementations like Histogram Aggregation,\n * Date Histogram aggregation.\n *\n * **NOTE:** Instantiating this directly should not be required.\n * However, if you wish to add a custom implementation for whatever reason,\n * this class could be extended.\n *\n * @param {string} name The name which will be used to refer to this aggregation.\n * @param {string} aggType Type of aggregation\n * @param {string=} field The field to aggregate on\n * @param {string|number=} interval Interval to generate histogram over.\n *\n * @extends BucketAggregationBase\n */\n\nvar HistogramAggregationBase = function (_BucketAggregationBas) {\n  (0, _inherits3.default)(HistogramAggregationBase, _BucketAggregationBas); // eslint-disable-next-line require-jsdoc\n\n  function HistogramAggregationBase(name, aggType, field, interval) {\n    (0, _classCallCheck3.default)(this, HistogramAggregationBase);\n\n    var _this = (0, _possibleConstructorReturn3.default)(this, (HistogramAggregationBase.__proto__ || Object.getPrototypeOf(HistogramAggregationBase)).call(this, name, aggType, field));\n\n    if (!isNil(interval)) _this._aggsDef.interval = interval;\n    return _this;\n  }\n  /**\n   * Sets the histogram interval. Buckets are generated based on this interval value.\n   *\n   * @param {string} interval Interval to generate histogram over.\n   * For date histograms, available expressions for interval:\n   * year, quarter, month, week, day, hour, minute, second\n   * @returns {HistogramAggregationBase} returns `this` so that calls can be chained\n   */\n\n\n  (0, _createClass3.default)(HistogramAggregationBase, [{\n    key: 'interval',\n    value: function interval(_interval) {\n      this._aggsDef.interval = _interval;\n      return this;\n    }\n    /**\n     * Sets the format expression for `key_as_string` in response buckets.\n     * If no format is specified, then it will use the first format specified in the field mapping.\n     *\n     * @example\n     * const agg = esb.dateHistogramAggregation(\n     *     'sales_over_time',\n     *     'date',\n     *     '1M'\n     * ).format('yyyy-MM-dd');\n     *\n     * @param {string} fmt Format mask to apply on aggregation response. Example: ####.00.\n     * For Date Histograms, supports expressive [date format pattern](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-daterange-aggregation.html#date-format-pattern)\n     * @returns {HistogramAggregationBase} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'format',\n    value: function format(fmt) {\n      this._aggsDef.format = fmt;\n      return this;\n    }\n    /**\n     * The offset parameter is used to change the start value of each bucket\n     * by the specified positive (+) or negative offset (-).\n     * Negative offset is not applicable on HistogramAggregation.\n     * In case of DateHistogramAggregation, duration can be\n     * a value such as 1h for an hour, or 1d for a day.\n     *\n     * @example\n     * const agg = esb.dateHistogramAggregation('by_day', 'date', 'day').offset('6h');\n     *\n     * @param {string} offset Time or bucket key offset for bucketing.\n     * @returns {HistogramAggregationBase} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'offset',\n    value: function offset(_offset) {\n      this._aggsDef.offset = _offset;\n      return this;\n    }\n    /**\n     * Sets the ordering for buckets\n     *\n     * @example\n     * const agg = esb.histogramAggregation('prices', 'price', 50)\n     *     .order('_count', 'desc');\n     *\n     * @example\n     * const agg = esb.histogramAggregation('prices', 'price', 50)\n     *     .order('promoted_products>rating_stats.avg', 'desc')\n     *     .agg(\n     *         esb.filterAggregation('promoted_products')\n     *             .filter(esb.termQuery('promoted', 'true'))\n     *             .agg(esb.statsAggregation('rating_stats', 'rating'))\n     *     );\n     *\n     * @param {string} key\n     * @param {string} direction `asc` or `desc`\n     * @returns {HistogramAggregationBase} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'order',\n    value: function order(key) {\n      var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'desc';\n      if (isNil(direction)) invalidDirectionParam(direction);\n      var directionLower = direction.toLowerCase();\n\n      if (directionLower !== 'asc' && directionLower !== 'desc') {\n        invalidDirectionParam(direction);\n      }\n\n      if (has(this._aggsDef, 'order')) {\n        if (!Array.isArray(this._aggsDef.order)) {\n          this._aggsDef.order = [this._aggsDef.order];\n        }\n\n        this._aggsDef.order.push((0, _defineProperty3.default)({}, key, directionLower));\n      } else {\n        this._aggsDef.order = (0, _defineProperty3.default)({}, key, directionLower);\n      }\n\n      return this;\n    }\n    /**\n     * Sets the minimum number of matching documents in range to return the bucket.\n     *\n     * @example\n     * const agg = esb.histogramAggregation('prices', 'price', 50).minDocCount(1);\n     *\n     * @param {number} minDocCnt Integer value for minimum number of documents\n     * required to return bucket in response\n     * @returns {HistogramAggregationBase} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'minDocCount',\n    value: function minDocCount(minDocCnt) {\n      this._aggsDef.min_doc_count = minDocCnt;\n      return this;\n    }\n    /**\n     * Set's the range/bounds for the histogram aggregation.\n     * Useful when you want to include buckets that might be\n     * outside the bounds of indexed documents.\n     *\n     * @example\n     * const agg = esb.histogramAggregation('prices', 'price', 50).extendedBounds(0, 500);\n     *\n     * @param {number|string} min Start bound / minimum bound value\n     * For histogram aggregation, Integer value can be used.\n     * For Date histogram, date expression can be used.\n     * Available expressions for interval:\n     * year, quarter, month, week, day, hour, minute, second\n     * @param {number|string} max End bound / maximum bound value\n     * For histogram aggregation, Integer value can be used.\n     * For Date histogram, date expression can be used.\n     * Available expressions for interval:\n     * year, quarter, month, week, day, hour, minute, second\n     * @returns {HistogramAggregationBase} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'extendedBounds',\n    value: function extendedBounds(min, max) {\n      this._aggsDef.extended_bounds = {\n        min: min,\n        max: max\n      };\n      return this;\n    }\n    /**\n     * Sets the missing parameter which defines how documents\n     * that are missing a value should be treated.\n     *\n     * @example\n     * const agg = esb.histogramAggregation('quantity', 'quantity', 10).missing(0);\n     *\n     * @param {string} value\n     * @returns {HistogramAggregationBase} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'missing',\n    value: function missing(value) {\n      this._aggsDef.missing = value;\n      return this;\n    }\n    /**\n     * Enable the response to be returned as a keyed object where the key is the\n     * bucket interval.\n     *\n     * @example\n     * const agg = esb.dateHistogramAggregation('sales_over_time', 'date', '1M')\n     *     .keyed(true)\n     *     .format('yyyy-MM-dd');\n     *\n     * @param {boolean} keyed To enable keyed response or not.\n     * @returns {HistogramAggregationBase} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'keyed',\n    value: function keyed(_keyed) {\n      this._aggsDef.keyed = _keyed;\n      return this;\n    }\n  }]);\n  return HistogramAggregationBase;\n}(BucketAggregationBase);\n\nmodule.exports = HistogramAggregationBase;","map":null,"metadata":{},"sourceType":"script"}