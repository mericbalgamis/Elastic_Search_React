{"ast":null,"code":"'use strict';\n\nvar _defineProperty2 = require('babel-runtime/helpers/defineProperty');\n\nvar _defineProperty3 = _interopRequireDefault(_defineProperty2);\n\nvar _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');\n\nvar _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar has = require('lodash.has');\n\nvar isEmpty = require('lodash.isempty');\n\nvar _require = require('./util'),\n    checkType = _require.checkType,\n    recursiveToJSON = _require.recursiveToJSON;\n/**\n * Base class implementation for all aggregation types.\n *\n * **NOTE:** Instantiating this directly should not be required.\n * However, if you wish to add a custom implementation for whatever reason,\n * this class should be extended and used, as validation against the class\n * type is present in various places.\n *\n * @param {string} name\n * @param {string} aggType Type of aggregation\n *\n * @throws {Error} if `name` is empty\n * @throws {Error} if `aggType` is empty\n */\n\n\nvar Aggregation = function () {\n  // eslint-disable-next-line require-jsdoc\n  function Aggregation(name, aggType) {\n    (0, _classCallCheck3.default)(this, Aggregation);\n    if (isEmpty(aggType)) throw new Error('Aggregation `aggType` cannot be empty');\n    this._name = name;\n    this.aggType = aggType;\n    this._aggs = {};\n    this._aggsDef = this._aggs[aggType] = {};\n    this._nestedAggs = [];\n  } // TODO: Investigate case when getter for aggregation will be required\n\n  /**\n   * Sets name for aggregation.\n   *\n   * @param {string} name returns `this` so that calls can be chained.\n   * @returns {Aggregation}\n   */\n\n\n  (0, _createClass3.default)(Aggregation, [{\n    key: 'name',\n    value: function name(_name) {\n      this._name = _name;\n      return this;\n    }\n    /**\n     * Sets nested aggregations.\n     * This method can be called multiple times in order to set multiple nested aggregations.\n     *\n     * @param {Aggregation} agg Any valid {@link Aggregation}\n     * @returns {Aggregation} returns `this` so that calls can be chained.\n     * @throws {TypeError} If `agg` is not an instance of `Aggregation`\n     */\n\n  }, {\n    key: 'aggregation',\n    value: function aggregation(agg) {\n      checkType(agg, Aggregation); // Possible to check for Global aggregation?\n      // Global aggregation can only be at the top level.\n\n      this._nestedAggs.push(agg);\n\n      return this;\n    }\n    /**\n     * Sets nested aggregation.\n     * This method can be called multiple times in order to set multiple nested aggregations.\n     *\n     * @param {Aggregation} agg Any valid {@link Aggregation}\n     * @returns {Aggregation} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'agg',\n    value: function agg(_agg) {\n      return this.aggregation(_agg);\n    }\n    /**\n     * Sets multiple nested aggregation items.\n     * This method accepts an array to set multiple nested aggregations in one call.\n     *\n     * @param {Array<Aggregation>} aggs Array of valid {@link Aggregation} items\n     * @returns {Aggregation} returns `this` so that calls can be chained.\n     * @throws {TypeError} If `aggs` is not an instance of `Array`\n     * @throws {TypeError} If `aggs` contains instances not of type `Aggregation`\n     */\n\n  }, {\n    key: 'aggregations',\n    value: function aggregations(aggs) {\n      var _this = this;\n\n      checkType(aggs, Array);\n      aggs.forEach(function (agg) {\n        return _this.aggregation(agg);\n      });\n      return this;\n    }\n    /**\n     * Sets multiple nested aggregation items.\n     * Alias for method `aggregations`\n     *\n     * @param {Array<Aggregation>} aggs Array of valid {@link Aggregation} items\n     * @returns {Aggregation} returns `this` so that calls can be chained.\n     * @throws {TypeError} If `aggs` is not an instance of `Array`\n     * @throws {TypeError} If `aggs` contains instances not of type `Aggregation`\n     */\n\n  }, {\n    key: 'aggs',\n    value: function aggs(_aggs) {\n      return this.aggregations(_aggs);\n    }\n    /**\n     * You can associate a piece of metadata with individual aggregations at request time\n     * that will be returned in place at response time.\n     *\n     * @param {Object} meta\n     * @returns {Aggregation} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'meta',\n    value: function meta(_meta) {\n      this._aggs.meta = _meta;\n      return this;\n    }\n    /**\n     * Internal helper function for determining the aggregation name.\n     *\n     * @returns {string} Aggregation name\n     * @private\n     */\n\n  }, {\n    key: '_aggsName',\n    value: function _aggsName() {\n      if (!isEmpty(this._name)) return this._name;\n\n      if (has(this._aggsDef, 'field')) {\n        return 'agg_' + this.aggType + '_' + this._aggsDef.field;\n      } // At this point, it would be difficult to construct a unique\n      // aggregation name. Error out.\n\n\n      throw new Error('Aggregation name could not be determined');\n    }\n    /**\n     * Build and returns DSL representation of the `Aggregation` class instance.\n     *\n     * @returns {Object} returns an Object which maps to the elasticsearch query DSL\n     */\n\n  }, {\n    key: 'getDSL',\n    value: function getDSL() {\n      return this.toJSON();\n    }\n    /**\n     * Override default `toJSON` to return DSL representation for the `aggregation` query.\n     *\n     * @override\n     * @returns {Object} returns an Object which maps to the elasticsearch query DSL\n     */\n\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      var mainAggs = recursiveToJSON(this._aggs);\n\n      if (!isEmpty(this._nestedAggs)) {\n        mainAggs.aggs = Object.assign.apply(Object, [{}].concat((0, _toConsumableArray3.default)(recursiveToJSON(this._nestedAggs))));\n      }\n\n      return (0, _defineProperty3.default)({}, this._aggsName(), mainAggs);\n    }\n  }]);\n  return Aggregation;\n}();\n\nmodule.exports = Aggregation;","map":null,"metadata":{},"sourceType":"script"}