{"ast":null,"code":"'use strict';\n\nvar _defineProperty2 = require('babel-runtime/helpers/defineProperty');\n\nvar _defineProperty3 = _interopRequireDefault(_defineProperty2);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');\n\nvar _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar has = require('lodash.has'),\n    isNil = require('lodash.isnil'),\n    isEmpty = require('lodash.isempty');\n\nvar Query = require('./query'),\n    Aggregation = require('./aggregation'),\n    Suggester = require('./suggester'),\n    Rescore = require('./rescore'),\n    Sort = require('./sort'),\n    Highlight = require('./highlight'),\n    InnerHits = require('./inner-hits');\n\nvar _require = require('./util'),\n    checkType = _require.checkType,\n    setDefault = _require.setDefault,\n    recursiveToJSON = _require.recursiveToJSON;\n/**\n * Helper function to call `recursiveToJSON` on elements of array and assign to object.\n *\n * @private\n *\n * @param {Array} arr\n * @returns {Object}\n */\n\n\nfunction recMerge(arr) {\n  return Object.assign.apply(Object, [{}].concat((0, _toConsumableArray3.default)(recursiveToJSON(arr))));\n}\n/**\n * The `RequestBodySearch` object provides methods generating an elasticsearch\n * search request body. The search request can be executed with a search DSL,\n * which includes the Query DSL, within its body.\n *\n * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-body.html)\n *\n * @example\n * const reqBody = esb.requestBodySearch()\n *     .query(esb.termQuery('user', 'kimchy'))\n *     .from(0)\n *     .size(10);\n *\n * reqBody.toJSON();\n * {\n *   \"query\": { \"term\": { \"user\": \"kimchy\" } },\n *   \"from\": 0,\n *   \"size\": 10\n * }\n *\n * @example\n * // Query and aggregation\n * const reqBody = esb.requestBodySearch()\n *     .query(esb.matchQuery('business_type', 'shop'))\n *     .agg(\n *         esb.geoBoundsAggregation('viewport', 'location').wrapLongitude(true)\n *     );\n *\n * @example\n * // Query, aggregation with nested\n * const reqBody = esb.requestBodySearch()\n *     .query(esb.matchQuery('crime', 'burglary'))\n *     .agg(\n *         esb.termsAggregation('towns', 'town').agg(\n *             esb.geoCentroidAggregation('centroid', 'location')\n *         )\n *     );\n */\n\n\nvar RequestBodySearch = function () {\n  // eslint-disable-next-line require-jsdoc\n  function RequestBodySearch() {\n    (0, _classCallCheck3.default)(this, RequestBodySearch); // Maybe accept some optional parameter?\n\n    this._body = {};\n    this._aggs = [];\n    this._suggests = [];\n    this._suggestText = null;\n  }\n  /**\n   * Define query on the search request body using the Query DSL.\n   *\n   * @param {Query} query\n   * @returns {RequestBodySearch} returns `this` so that calls can be chained.\n   */\n\n\n  (0, _createClass3.default)(RequestBodySearch, [{\n    key: 'query',\n    value: function query(_query) {\n      checkType(_query, Query);\n      this._body.query = _query;\n      return this;\n    }\n    /**\n     * Sets aggregation on the request body.\n     * Alias for method `aggregation`\n     *\n     * @param {Aggregation} agg Any valid `Aggregation`\n     * @returns {RequestBodySearch} returns `this` so that calls can be chained.\n     * @throws {TypeError} If `agg` is not an instance of `Aggregation`\n     */\n\n  }, {\n    key: 'agg',\n    value: function agg(_agg) {\n      return this.aggregation(_agg);\n    }\n    /**\n     * Sets aggregation on the request body.\n     *\n     * @param {Aggregation} agg Any valid `Aggregation`\n     * @returns {RequestBodySearch} returns `this` so that calls can be chained.\n     * @throws {TypeError} If `agg` is not an instance of `Aggregation`\n     */\n\n  }, {\n    key: 'aggregation',\n    value: function aggregation(agg) {\n      checkType(agg, Aggregation);\n\n      this._aggs.push(agg);\n\n      return this;\n    }\n    /**\n     * Sets multiple nested aggregation items.\n     * Alias for method `aggregations`\n     *\n     * @param {Array<Aggregation>} aggs Array of valid {@link Aggregation} items\n     * @returns {Aggregation} returns `this` so that calls can be chained.\n     * @throws {TypeError} If `aggs` is not an instance of `Array`\n     * @throws {TypeError} If `aggs` contains instances not of type `Aggregation`\n     */\n\n  }, {\n    key: 'aggs',\n    value: function aggs(_aggs) {\n      return this.aggregations(_aggs);\n    }\n    /**\n     * Sets multiple nested aggregation items.\n     * This method accepts an array to set multiple nested aggregations in one call.\n     *\n     * @param {Array<Aggregation>} aggs Array of valid {@link Aggregation} items\n     * @returns {Aggregation} returns `this` so that calls can be chained.\n     * @throws {TypeError} If `aggs` is not an instance of `Array`\n     * @throws {TypeError} If `aggs` contains instances not of type `Aggregation`\n     */\n\n  }, {\n    key: 'aggregations',\n    value: function aggregations(aggs) {\n      var _this = this;\n\n      checkType(aggs, Array);\n      aggs.forEach(function (agg) {\n        return _this.aggregation(agg);\n      });\n      return this;\n    }\n    /**\n     * Sets suggester on the request body.\n     *\n     * @example\n     * const req = esb.requestBodySearch()\n     *     .query(esb.matchQuery('message', 'trying out elasticsearch'))\n     *     .suggest(\n     *         esb.termSuggester(\n     *             'my-suggestion',\n     *             'message',\n     *             'tring out Elasticsearch'\n     *         )\n     *     );\n     *\n     * @param {Suggester} suggest Any valid `Suggester`\n     * @returns {RequestBodySearch} returns `this` so that calls can be chained.\n     * @throws {TypeError} If `suggest` is not an instance of `Suggester`\n     */\n\n  }, {\n    key: 'suggest',\n    value: function suggest(_suggest) {\n      checkType(_suggest, Suggester);\n\n      this._suggests.push(_suggest);\n\n      return this;\n    }\n    /**\n     * Sets the global suggest text to avoid repetition for multiple suggestions.\n     *\n     * @example\n     * const req = esb.requestBodySearch()\n     *     .suggestText('tring out elasticsearch')\n     *     .suggest(esb.termSuggester('my-suggest-1', 'message'))\n     *     .suggest(esb.termSuggester('my-suggest-2', 'user'));\n     *\n     * @param {string} txt Global suggest text\n     * @returns {RequestBodySearch} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'suggestText',\n    value: function suggestText(txt) {\n      this._suggestText = txt;\n      return this;\n    }\n    /**\n     * Sets a search timeout, bounding the search request to be executed within\n     * the specified time value and bail with the hits accumulated up to that\n     * point when expired.\n     *\n     * @param {string} timeout Duration can be specified using\n     * [time units](https://www.elastic.co/guide/en/elasticsearch/reference/current/common-options.html#time-units)\n     * Defaults to no timeout.\n     * @returns {RequestBodySearch} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'timeout',\n    value: function timeout(_timeout) {\n      this._body.timeout = _timeout;\n      return this;\n    }\n    /**\n     * To retrieve hits from a certain offset.\n     *\n     * @param {number} from Defaults to 0.\n     * @returns {RequestBodySearch} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'from',\n    value: function from(_from) {\n      this._body.from = _from;\n      return this;\n    }\n    /**\n     * The number of hits to return. If you do not care about getting some hits back\n     * but only about the number of matches and/or aggregations, setting the value\n     * to 0 will help performance.\n     *\n     * @param {number} size Defaults to 10.\n     * @returns {RequestBodySearch} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'size',\n    value: function size(_size) {\n      this._body.size = _size;\n      return this;\n    }\n    /**\n     * The maximum number of documents to collect for each shard, upon reaching which\n     * the query execution will terminate early. If set, the response will have a\n     * boolean field `terminated_early` to indicate whether the query execution has\n     * actually terminated early.\n     *\n     * @param {number} numberOfDocs Maximum number of documents to collect for each shard.\n     * Defaults to no limit.\n     * @returns {RequestBodySearch} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'terminateAfter',\n    value: function terminateAfter(numberOfDocs) {\n      this._body.terminate_after = numberOfDocs;\n      return this;\n    }\n    /**\n     * Allows to add sort on specific field. The sort can be reversed as well.\n     * The sort is defined on a per field level, with special field name for `_score` to\n     * sort by score, and `_doc` to sort by index order.\n     *\n     * @example\n     * const reqBody = esb.requestBodySearch()\n     *     .query(esb.termQuery('user', 'kimchy'))\n     *     .sort(esb.sort('post_date', 'asc'))\n     *     .sort(esb.sort('user'))\n     *     .sorts([\n     *         esb.sort('name', 'desc'),\n     *         esb.sort('age', 'desc'),\n     *         esb.sort('_score')\n     *     ]);\n     *\n     * @param {Sort} sort\n     * @returns {RequestBodySearch} returns `this` so that calls can be chained.\n     * @throws {TypeError} If parameter `sort` is not an instance of `Sort`.\n     */\n\n  }, {\n    key: 'sort',\n    value: function sort(_sort) {\n      checkType(_sort, Sort);\n      setDefault(this._body, 'sort', []);\n\n      this._body.sort.push(_sort);\n\n      return this;\n    }\n    /**\n     * Allows to add multiple sort on specific fields. Each sort can be reversed as well.\n     * The sort is defined on a per field level, with special field name for _score to\n     * sort by score, and _doc to sort by index order.\n     *\n     * @example\n     * const reqBody = esb.requestBodySearch()\n     *     .query(esb.termQuery('user', 'kimchy'))\n     *     .sort(esb.sort('post_date', 'asc'))\n     *     .sort(esb.sort('user'))\n     *     .sorts([\n     *         esb.sort('name', 'desc'),\n     *         esb.sort('age', 'desc'),\n     *         esb.sort('_score')\n     *     ]);\n     *\n     * @param {Array<Sort>} sorts Arry of sort\n     * @returns {RequestBodySearch} returns `this` so that calls can be chained.\n     * @throws {TypeError} If any item in parameter `sorts` is not an instance of `Sort`.\n     */\n\n  }, {\n    key: 'sorts',\n    value: function sorts(_sorts) {\n      var _this2 = this;\n\n      _sorts.forEach(function (sort) {\n        return _this2.sort(sort);\n      });\n\n      return this;\n    }\n    /**\n     * When sorting on a field, scores are not computed. By setting `track_scores` to true,\n     * scores will still be computed and tracked.\n     *\n     * @example\n     * const reqBody = esb.requestBodySearch()\n     *     .trackScores(true)\n     *     .sorts([\n     *         esb.sort('post_date', 'desc'),\n     *         esb.sort('name', 'desc'),\n     *         esb.sort('age', 'desc')\n     *     ])\n     *     .query(esb.termQuery('user', 'kimchy'));\n      *\n     * @param {boolean} enable\n     * @returns {RequestBodySearch} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'trackScores',\n    value: function trackScores(enable) {\n      this._body.track_scores = enable;\n      return this;\n    }\n    /**\n     * Allows to control how the `_source` field is returned with every hit.\n     * You can turn off `_source` retrieval by passing `false`.\n     * It also accepts one(string) or more wildcard(array) patterns to control\n     * what parts of the `_source` should be returned\n     * An object can also be used to specify the wildcard patterns for `includes` and `excludes`.\n     *\n     * @example\n     * // To disable `_source` retrieval set to `false`:\n     * const reqBody = esb.requestBodySearch()\n     *     .query(esb.termQuery('user', 'kimchy'))\n     *     .source(false);\n     *\n     * @example\n     * // The `_source` also accepts one or more wildcard patterns to control what\n     * // parts of the `_source` should be returned:\n     * const reqBody = esb.requestBodySearch()\n     *     .query(esb.termQuery('user', 'kimchy'))\n     *     .source('obj.*');\n     *\n     * // OR\n     * const reqBody = esb.requestBodySearch()\n     *     .query(esb.termQuery('user', 'kimchy'))\n     *     .source([ 'obj1.*', 'obj2.*' ]);\n     *\n     * @example\n     * // For complete control, you can specify both `includes` and `excludes` patterns:\n     * const reqBody = esb.requestBodySearch()\n     *     .query(esb.termQuery('user', 'kimchy'))\n     *     .source({\n     *         'includes': [ 'obj1.*', 'obj2.*' ],\n     *         'excludes': [ '*.description' ]\n     *     });\n     *\n     * @param {boolean|string|Array|Object} source\n     * @returns {RequestBodySearch} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'source',\n    value: function source(_source) {\n      this._body._source = _source;\n      return this;\n    }\n    /**\n     * The `stored_fields` parameter is about fields that are explicitly marked as stored in the mapping.\n     * Selectively load specific stored fields for each document represented by a search hit\n     * using array of stored fields.\n     * An empty array will cause only the `_id` and `_type` for each hit to be returned.\n     * To disable the stored fields (and metadata fields) entirely use: `_none_`\n     *\n     * @example\n     * // Selectively load specific stored fields for each document\n     * // represented by a search hit\n     * const reqBody = esb.requestBodySearch()\n     *     .query(esb.termQuery('user', 'kimchy'))\n     *     .storedFields(['user', 'postDate']);\n     *\n     * @example\n     * // Return only the `_id` and `_type` to be returned:\n     * const reqBody = esb.requestBodySearch()\n     *     .query(esb.termQuery('user', 'kimchy'))\n     *     .storedFields([]);\n     *\n     * @example\n     * // Disable the stored fields (and metadata fields) entirely\n     * const reqBody = esb.requestBodySearch()\n     *     .query(esb.termQuery('user', 'kimchy'))\n     *     .storedFields('_none_');\n     *\n     * @param {Array|string} fields\n     * @returns {RequestBodySearch} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'storedFields',\n    value: function storedFields(fields) {\n      this._body.stored_fields = fields;\n      return this;\n    }\n    /**\n     * Computes a document property dynamically based on the supplied `Script`.\n     *\n     * @example\n     * const reqBody = esb.requestBodySearch()\n     *     .query(esb.matchAllQuery())\n     *     .scriptField(\n     *         'test1',\n     *         esb.script('inline', \"doc['my_field_name'].value * 2\").lang('painless')\n     *     )\n     *     .scriptField(\n     *         'test2',\n     *         esb.script('inline', \"doc['my_field_name'].value * factor\")\n     *             .lang('painless')\n     *             .params({ factor: 2.0 })\n     *     );\n     *\n     * @example\n     * // Script fields can also access the actual `_source` document and extract\n     * // specific elements to be returned from it by using `params['_source']`.\n     * const reqBody = esb.requestBodySearch()\n     *     .query(esb.matchAllQuery())\n     *     .scriptField('test1', \"params['_source']['message']\");\n     *\n     * @param {string} scriptFieldName\n     * @param {string|Script} script string or instance of `Script`\n     * @returns {RequestBodySearch} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'scriptField',\n    value: function scriptField(scriptFieldName, script) {\n      setDefault(this._body, 'script_fields', {});\n      this._body.script_fields[scriptFieldName] = {\n        script: script\n      };\n      return this;\n    }\n    /**\n     * Sets given dynamic document properties to be computed using supplied `Script`s.\n     *\n     * Object should have `scriptFieldName` as key and `script` as the value.\n     *\n     * @example\n     * const reqBody = esb.requestBodySearch()\n     *     .query(esb.matchAllQuery())\n     *     .scriptFields({\n     *         test1: esb\n     *             .script('inline', \"doc['my_field_name'].value * 2\")\n     *             .lang('painless'),\n     *         test2: esb\n     *             .script('inline', \"doc['my_field_name'].value * factor\")\n     *             .lang('painless')\n     *             .params({ factor: 2.0 })\n     *     });\n     *\n     * @example\n     * // Script fields can also access the actual `_source` document and extract\n     * // specific elements to be returned from it by using `params['_source']`.\n     * const reqBody = esb.requestBodySearch()\n     *     .query(esb.matchAllQuery())\n     *     .scriptFields({ test1: \"params['_source']['message']\" });\n     * @param {Object} scriptFields Object with `scriptFieldName` as key and `script` as the value.\n     * @returns {TopHitsAggregation} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'scriptFields',\n    value: function scriptFields(_scriptFields) {\n      var _this3 = this;\n\n      checkType(_scriptFields, Object);\n      Object.keys(_scriptFields).forEach(function (scriptFieldName) {\n        return _this3.scriptField(scriptFieldName, _scriptFields[scriptFieldName]);\n      });\n      return this;\n    }\n    /**\n     * Allows to return the doc value representation of a field for each hit.\n     * Doc value fields can work on fields that are not stored.\n     *\n     * @example\n     * const reqBody = esb.requestBodySearch()\n     *     .query(esb.matchAllQuery())\n     *     .docvalueFields(['test1', 'test2']);\n     *\n     * @param {Array<string>} fields\n     * @returns {RequestBodySearch} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'docvalueFields',\n    value: function docvalueFields(fields) {\n      this._body.docvalue_fields = fields;\n      return this;\n    }\n    /**\n     * The `post_filter` is applied to the search hits at the very end of a search request,\n     * after aggregations have already been calculated.\n     *\n     * @example\n     * const reqBody = esb.requestBodySearch()\n     *     .query(esb.boolQuery().filter(esb.termQuery('brand', 'gucci')))\n     *     .agg(esb.termsAggregation('colors', 'color'))\n     *     .agg(\n     *         esb.filterAggregation(\n     *             'color_red',\n     *             esb.termQuery('color', 'red')\n     *         ).agg(esb.termsAggregation('models', 'model'))\n     *     )\n     *     .postFilter(esb.termQuery('color', 'red'));\n     *\n     * @param {Query} filterQuery The filter to be applied after aggregation.\n     * @returns {RequestBodySearch} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'postFilter',\n    value: function postFilter(filterQuery) {\n      checkType(filterQuery, Query);\n      this._body.post_filter = filterQuery;\n      return this;\n    }\n    /**\n     * Allows to highlight search results on one or more fields. The implementation\n     * uses either the lucene `plain` highlighter, the fast vector highlighter (`fvh`)\n     * or `postings` highlighter.\n     *\n     * Note: The `postings` highlighter has been removed in elasticsearch 6.0.\n     * The `unified` highlighter outputs the same highlighting when\n     * `index_options` is set to `offsets`.\n     *\n     * @example\n     * const reqBody = esb.requestBodySearch()\n     *     .query(esb.matchAllQuery())\n     *     .highlight(esb.highlight('content'));\n     *\n     * @example\n     * const reqBody = esb.requestBodySearch()\n     *     .query(\n     *         esb.percolateQuery('query', 'doctype').document({\n     *             message: 'The quick brown fox jumps over the lazy dog'\n     *         })\n     *     )\n     *     .highlight(esb.highlight('message'));\n     *\n     * @param {Highlight} highlight\n     * @returns {RequestBodySearch} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'highlight',\n    value: function highlight(_highlight) {\n      checkType(_highlight, Highlight);\n      this._body.highlight = _highlight;\n      return this;\n    }\n    /**\n     * Rescoring can help to improve precision by reordering just the top (eg 100 - 500)\n     * documents returned by the `query` and `post_filter` phases, using a secondary\n     * (usually more costly) algorithm, instead of applying the costly algorithm to\n     * all documents in the index.\n     *\n     * @example\n     * const reqBody = esb.requestBodySearch()\n     *     .query(esb.matchQuery('message', 'the quick brown').operator('or'))\n     *     .rescore(\n     *         esb.rescore(\n     *             50,\n     *             esb.matchPhraseQuery('message', 'the quick brown').slop(2)\n     *         )\n     *             .queryWeight(0.7)\n     *             .rescoreQueryWeight(1.2)\n     *     );\n     *\n     * @example\n     * const reqBody = esb.requestBodySearch()\n     *     .query(esb.matchQuery('message', 'the quick brown').operator('or'))\n     *     .rescore(\n     *         esb.rescore(\n     *             100,\n     *             esb.matchPhraseQuery('message', 'the quick brown').slop(2)\n     *         )\n     *             .queryWeight(0.7)\n     *             .rescoreQueryWeight(1.2)\n     *     )\n     *     .rescore(\n     *         esb.rescore(\n     *             10,\n     *             esb.functionScoreQuery().function(\n     *                 esb.scriptScoreFunction(\n     *                     esb.script('inline', 'Math.log10(doc.likes.value + 2)')\n     *                 )\n     *             )\n     *         ).scoreMode('multiply')\n     *     );\n     *\n     * @param {Rescore} rescore\n     * @returns {RequestBodySearch} returns `this` so that calls can be chained\n     * @throws {TypeError} If `query` is not an instance of `Rescore`\n     */\n\n  }, {\n    key: 'rescore',\n    value: function rescore(_rescore) {\n      checkType(_rescore, Rescore);\n\n      if (has(this._body, 'rescore')) {\n        if (!Array.isArray(this._body.rescore)) {\n          this._body.rescore = [this._body.rescore];\n        }\n\n        this._body.rescore.push(_rescore);\n      } else this._body.rescore = _rescore;\n\n      return this;\n    } // TODO: Scroll related changes\n    // Maybe only slice needs to be supported.\n\n    /**\n     * Enables explanation for each hit on how its score was computed.\n     *\n     * @example\n     * const reqBody = esb.requestBodySearch()\n     *     .query(esb.termQuery('user', 'kimchy'))\n     *     .explain(true);\n     *\n     * @param {boolean} enable\n     * @returns {RequestBodySearch} returns `this` so that calls can be chained\n     */\n\n  }, {\n    key: 'explain',\n    value: function explain(enable) {\n      this._body.explain = enable;\n      return this;\n    }\n    /**\n     * Returns a version for each search hit.\n     *\n     * @example\n     * const reqBody = esb.requestBodySearch()\n     *     .query(esb.termQuery('user', 'kimchy'))\n     *     .version(true);\n     *\n     * @param {boolean} enable\n     * @returns {RequestBodySearch} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'version',\n    value: function version(enable) {\n      this._body.version = enable;\n      return this;\n    }\n    /**\n     * Allows to configure different boost level per index when searching across\n     * more than one indices. This is very handy when hits coming from one index\n     * matter more than hits coming from another index.\n     *\n     * Alias for method `indicesBoost`.\n     *\n     * @example\n     * const reqBody = esb.requestBodySearch()\n     *     .indexBoost('alias1', 1.4)\n     *     .indexBoost('index*', 1.3);\n     *\n     * @param {string} index Index windcard expression or alias\n     * @param {number} boost\n     * @returns {RequestBodySearch} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'indexBoost',\n    value: function indexBoost(index, boost) {\n      return this.indicesBoost(index, boost);\n    }\n    /**\n     * Allows to configure different boost level per index when searching across\n     * more than one indices. This is very handy when hits coming from one index\n     * matter more than hits coming from another index.\n     *\n     * @example\n     * const reqBody = esb.requestBodySearch()\n     *     .indicesBoost('alias1', 1.4)\n     *     .indicesBoost('index*', 1.3);\n     *\n     * @param {string} index Index windcard expression or alias\n     * @param {number} boost\n     * @returns {RequestBodySearch} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'indicesBoost',\n    value: function indicesBoost(index, boost) {\n      setDefault(this._body, 'indices_boost', []);\n\n      this._body.indices_boost.push((0, _defineProperty3.default)({}, index, boost));\n\n      return this;\n    }\n    /**\n     * Exclude documents which have a `_score` less than the minimum specified in `min_score`.\n     *\n     * @example\n     * const reqBody = esb.requestBodySearch()\n     *     .query(esb.termQuery('user', 'kimchy'))\n     *     .minScore(0.5);\n     *\n     * @param {number} score\n     * @returns {RequestBodySearch} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'minScore',\n    value: function minScore(score) {\n      this._body.min_score = score;\n      return this;\n    }\n    /**\n     * Allows to collapse search results based on field values. The collapsing\n     * is done by selecting only the top sorted document per collapse key.\n     *\n     * The field used for collapsing must be a single valued `keyword` or `numeric`\n     * field with `doc_values` activated\n     *\n     * @example\n     * const reqBody = esb.requestBodySearch()\n     *     .query(esb.matchQuery('message', 'elasticsearch'))\n     *     .collapse('user')\n     *     .sort(esb.sort('likes'))\n     *     .from(10);\n     *\n     * @example\n     * // Expand each collapsed top hits with the `inner_hits` option:\n     * const reqBody = esb.requestBodySearch()\n     *     .query(esb.matchQuery('message', 'elasticsearch'))\n     *     .collapse(\n     *         'user',\n     *         esb.innerHits('last_tweets')\n     *             .size(5)\n     *             .sort(esb.sort('date', 'asc')),\n     *         4\n     *     )\n     *     .sort(esb.sort('likes'))\n     *     .from(10);\n     *\n     * @param {string} field\n     * @param {InnerHits=} innerHits Allows to expand each collapsed top hits.\n     * @param {number=} maxConcurrentGroupRequests The number of concurrent\n     * requests allowed to retrieve the inner_hits' per group\n     * @returns {RequestBodySearch} returns `this` so that calls can be chained.\n     * @throws {TypeError} If `innerHits` is not an instance of `InnerHits`\n     */\n\n  }, {\n    key: 'collapse',\n    value: function collapse(field, innerHits, maxConcurrentGroupRequests) {\n      var collapse = this._body.collapse = {\n        field: field\n      };\n\n      if (!isNil(innerHits)) {\n        checkType(innerHits, InnerHits);\n        collapse.inner_hits = innerHits;\n        collapse.max_concurrent_group_searches = maxConcurrentGroupRequests;\n      }\n\n      return this;\n    }\n    /**\n     * Allows to use the results from the previous page to help the retrieval\n     * of the next page. The `search_after` parameter provides a live cursor.\n     *\n     * The parameter `from` must be set to `0` (or `-1`) when `search_after` is used.\n     *\n     * @example\n     * const reqBody = esb.requestBodySearch()\n     *     .size(10)\n     *     .query(esb.matchQuery('message', 'elasticsearch'))\n     *     .searchAfter(1463538857, 'tweet#654323')\n     *     .sorts([esb.sort('date', 'asc'), esb.sort('_uid', 'desc')]);\n     *\n     * @param {Array<*>} values The `sort values` of the last document to retrieve\n     * the next page of results\n     * @returns {RequestBodySearch} returns `this` so that calls can be chained.\n     */\n\n  }, {\n    key: 'searchAfter',\n    value: function searchAfter(values) {\n      this._body.search_after = values;\n      return this;\n    }\n    /**\n     * Override default `toJSON` to return DSL representation for the request body search\n     *\n     * @override\n     * @returns {Object} returns an Object which maps to the elasticsearch query DSL\n     */\n\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      var dsl = recursiveToJSON(this._body);\n      if (!isEmpty(this._aggs)) dsl.aggs = recMerge(this._aggs);\n\n      if (!isEmpty(this._suggests) || !isNil(this._suggestText)) {\n        dsl.suggest = recMerge(this._suggests);\n\n        if (!isNil(this._suggestText)) {\n          dsl.suggest.text = this._suggestText;\n        }\n      }\n\n      return dsl;\n    }\n  }]);\n  return RequestBodySearch;\n}();\n\nmodule.exports = RequestBodySearch;","map":null,"metadata":{},"sourceType":"script"}